
===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Fog\FogOfWar.cs =====
using System;

namespace MineIt.Fog
{
    public sealed class FogOfWar
    {
        private readonly int _w;
        private readonly int _h;

        // Discovered persists (bitset)
        private readonly uint[] _discoveredBits;

        // VisibleNow is per-frame (bool array is fine at 512x512)
        private readonly bool[] _visibleNow;

        public int Width => _w;
        public int Height => _h;

        public FogOfWar(int width, int height)
        {
            _w = width;
            _h = height;

            int bitCount = width * height;
            _discoveredBits = new uint[(bitCount + 31) / 32];
            _visibleNow = new bool[bitCount];
        }

        public void ClearVisibleNow()
        {
            Array.Clear(_visibleNow, 0, _visibleNow.Length);
        }

        public bool IsDiscovered(int tx, int ty)
        {
            if ((uint)tx >= (uint)_w || (uint)ty >= (uint)_h) return false;
            int i = ty * _w + tx;
            int word = i >> 5;
            int bit = i & 31;
            return ((_discoveredBits[word] >> bit) & 1u) != 0;
        }

        public bool IsVisibleNow(int tx, int ty)
        {
            if ((uint)tx >= (uint)_w || (uint)ty >= (uint)_h) return false;
            return _visibleNow[ty * _w + tx];
        }

        public void RevealCircle(int cx, int cy, int radiusTiles)
        {
            int r2 = radiusTiles * radiusTiles;

            int minX = Math.Max(0, cx - radiusTiles);
            int maxX = Math.Min(_w - 1, cx + radiusTiles);
            int minY = Math.Max(0, cy - radiusTiles);
            int maxY = Math.Min(_h - 1, cy + radiusTiles);

            for (int y = minY; y <= maxY; y++)
                for (int x = minX; x <= maxX; x++)
                {
                    int dx = x - cx;
                    int dy = y - cy;
                    if (dx * dx + dy * dy > r2) continue;

                    // visible now
                    _visibleNow[y * _w + x] = true;

                    // discovered persistent
                    int i = y * _w + x;
                    int word = i >> 5;
                    int bit = i & 31;
                    _discoveredBits[word] |= (1u << bit);
                }
        }

        public uint[] CopyDiscoveredBits()
        {
            var copy = new uint[_discoveredBits.Length];
            Array.Copy(_discoveredBits, copy, _discoveredBits.Length);
            return copy;
        }

        public void OverwriteDiscoveredBits(uint[] bits)
        {
            if (bits == null) return;

            int n = Math.Min(bits.Length, _discoveredBits.Length);
            Array.Clear(_discoveredBits, 0, _discoveredBits.Length);
            Array.Copy(bits, _discoveredBits, n);
        }

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Input\InputSnapshot.cs =====
namespace MineIt.Input
{
    public struct InputSnapshot
    {
        public bool MoveUp { get; set; }
        public bool MoveDown { get; set; }
        public bool MoveLeft { get; set; }
        public bool MoveRight { get; set; }

        // One-frame actions
        public bool ScanPressed { get; set; }
        public bool ClaimPressed { get; set; }
        public bool ExtractPressed { get; set; }  // NEW: one-frame extraction action (E)
        public bool DepositPressed { get; set; }  // NEW: deposit backpack into town storage (T)
        public bool SellPressed { get; set; }   // NEW: sell ore for credits (Y)

        // Dev hotkeys (one-frame commands). 0 means "no command this frame".
        public int DevSetDetectorTier { get; set; }   // 1..5
        public int DevSetExtractorTier { get; set; }  // 1..5
        public int DevSetBackpackTier { get; set; }   // 1..5


    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Inventory\Backpack.cs =====
using System;
using System.Collections.Generic;

namespace MineIt.Inventory
{
    /// <summary>
    /// MVP backpack: ore-only inventory with mass-based capacity.
    /// Deterministic and allocation-light.
    /// </summary>
    public sealed class Backpack
    {
        private readonly Dictionary<string, int> _oreUnits = new Dictionary<string, int>(StringComparer.Ordinal);

        // Artifacts are NOT ore; they are unique quest items.
        // Stored as IDs (e.g., "stellar_shard").
        private readonly HashSet<string> _artifacts = new HashSet<string>(StringComparer.Ordinal);

        public System.Collections.Generic.IReadOnlyCollection<string> Artifacts => _artifacts;

        public double CapacityKg { get; set; } = 50.0;

        // Computed from contents; cached for speed (update on add/remove).
        public double CurrentKg { get; private set; }

        public IReadOnlyDictionary<string, int> OreUnits => _oreUnits;

        public double RemainingKg => Math.Max(0.0, CapacityKg - CurrentKg);

        public bool IsFull => CurrentKg >= CapacityKg - 1e-9;

        public int GetUnits(string oreId)
            => _oreUnits.TryGetValue(oreId, out var u) ? u : 0;

        public bool CanAddOreUnits(string oreId, int units)
        {
            if (units <= 0) return true;
            double addKg = units * OreCatalog.UnitMassKg(oreId);
            return CurrentKg + addKg <= CapacityKg + 1e-9;
        }

        public bool HasArtifact(string artifactId)
        {
            if (string.IsNullOrWhiteSpace(artifactId)) return false;
            return _artifacts.Contains(artifactId);
        }

        /// <summary>
        /// Adds an artifact by ID (unique). Returns true if newly added.
        /// </summary>
        public bool AddArtifact(string artifactId)
        {
            if (string.IsNullOrWhiteSpace(artifactId)) return false;
            return _artifacts.Add(artifactId);
        }

        /// <summary>
        /// Adds up to 'unitsRequested' ore units, bounded by capacity.
        /// Returns actual units added.
        /// </summary>
        public int AddOreUnitsClamped(string oreId, int unitsRequested)
        {
            if (unitsRequested <= 0) return 0;

            double unitKg = OreCatalog.UnitMassKg(oreId);
            if (unitKg <= 0) unitKg = 1.0;

            double roomKg = RemainingKg;
            int maxUnitsByWeight = (int)Math.Floor(roomKg / unitKg);
            if (maxUnitsByWeight <= 0) return 0;

            int addUnits = Math.Min(unitsRequested, maxUnitsByWeight);

            if (_oreUnits.TryGetValue(oreId, out var existing))
                _oreUnits[oreId] = existing + addUnits;
            else
                _oreUnits[oreId] = addUnits;

            CurrentKg += addUnits * unitKg;
            if (CurrentKg > CapacityKg) CurrentKg = CapacityKg; // guard

            return addUnits;
        }

        public void Clear()
        {
            _oreUnits.Clear();
            _artifacts.Clear();
            CurrentKg = 0.0;
        }

        /// <summary>
        /// Transfers all ore units to town storage, then clears the backpack.
        /// Deterministic, allocation-light, and avoids repeated logic in GameSession.
        /// </summary>
        public int TransferAllTo(TownStorage town)
        {
            if (town == null) return 0;

            int movedStacks = 0;

            if (_oreUnits.Count > 0)
            {
                foreach (var kv in _oreUnits)
                {
                    int units = kv.Value;
                    if (units <= 0) continue;

                    town.AddOreUnits(kv.Key, units);
                    movedStacks++;
                }
            }

            // Transfer artifacts (each counts as a "moved stack" for UX feedback)
            if (_artifacts.Count > 0)
            {
                foreach (var aid in _artifacts)
                {
                    town.AddArtifact(aid);
                    movedStacks++;
                }
            }

            Clear();
            return movedStacks;
        }

        public void LoadArtifacts(System.Collections.Generic.IEnumerable<string> artifactIds)
        {
            _artifacts.Clear();
            if (artifactIds == null) return;

            foreach (var id in artifactIds)
            {
                if (string.IsNullOrWhiteSpace(id)) continue;
                _artifacts.Add(id);
            }
        }

        public void LoadOreUnits(System.Collections.Generic.IEnumerable<MineIt.Save.StringIntPair> pairs)
        {
            Clear();
            if (pairs == null) return;

            foreach (var p in pairs)
            {
                if (p == null || string.IsNullOrEmpty(p.Key) || p.Value <= 0) continue;

                _oreUnits[p.Key] = p.Value;

                double unitKg = OreCatalog.UnitMassKg(p.Key);
                if (unitKg <= 0) unitKg = 1.0;
                CurrentKg += p.Value * unitKg;
            }

            if (CurrentKg > CapacityKg) CurrentKg = CapacityKg;
        }

        public void LoadOreUnits(System.Collections.Generic.IDictionary<string, int> oreUnits)
        {
            Clear();

            if (oreUnits == null) return;

            foreach (var kv in oreUnits)
            {
                string oreId = kv.Key;
                int units = kv.Value;
                if (units <= 0) continue;

                // Bypass clamping because save data should be authoritative.
                _oreUnits[oreId] = units;

                double unitKg = OreCatalog.UnitMassKg(oreId);
                if (unitKg <= 0) unitKg = 1.0;
                CurrentKg += units * unitKg;
            }

            // Never exceed capacity; keep deterministic and safe
            if (CurrentKg > CapacityKg) CurrentKg = CapacityKg;
        }

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Inventory\OreCatalog.cs =====
namespace MineIt.Inventory
{
    /// <summary>
    /// MVP in-code ore metadata (later replaced by ores.json).
    /// Keep deterministic and stable.
    /// </summary>
    public static class OreCatalog
    {
        public static double UnitMassKg(string oreId)
        {
            // These are reasonable placeholders; tune later or move to JSON.
            return oreId switch
            {
                "scrap" => 1.0,
                "iron" => 1.2,
                "copper" => 1.0,
                "quartz" => 0.8,
                "alum" => 0.9,
                "lithium" => 0.6,
                "titanium" => 1.1,
                "cobalt" => 1.0,
                "neodym" => 0.7,
                "gold" => 1.5,
                "plat" => 1.6,
                "xenon" => 0.9,
                "aether" => 0.5,
                "artifact" => 0.9,
                _ => 1.0
            };
        }

        public static double ExtractionDifficulty(string oreId)
        {
            // Placeholder difficulty curve; later comes from data.
            return oreId switch
            {
                "scrap" => 1.0,
                "iron" => 1.1,
                "copper" => 1.0,
                "quartz" => 1.2,
                "alum" => 1.0,
                "lithium" => 1.3,
                "titanium" => 1.4,
                "cobalt" => 1.5,
                "neodym" => 1.6,
                "gold" => 1.4,
                "plat" => 1.6,
                "xenon" => 1.8,
                "aether" => 2.0,
                "artifact" => 2.0,
                _ => 1.0
            };
        }

        public static int BasePricePerUnit(string oreId)
        {
            return oreId switch
            {
                "scrap" => 1,
                "iron" => 4,
                "copper" => 5,
                "quartz" => 6,
                "alum" => 7,
                "lithium" => 12,
                "titanium" => 15,
                "cobalt" => 18,
                "neodym" => 25,
                "gold" => 35,
                "plat" => 50,
                "xenon" => 80,
                "aether" => 120,
                "artifact" => 0,
                _ => 1
            };
        }

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Inventory\TownStorage.cs =====
using System;
using System.Collections.Generic;

namespace MineIt.Inventory
{
    /// <summary>
    /// MVP town storage: ore-only inventory with no capacity limit.
    /// </summary>
    public sealed class TownStorage
    {
        private readonly Dictionary<string, int> _oreUnits = new Dictionary<string, int>(StringComparer.Ordinal);

        // Artifacts are unique quest items; never sold.
        private readonly HashSet<string> _artifacts = new HashSet<string>(StringComparer.Ordinal);

        public System.Collections.Generic.IReadOnlyCollection<string> Artifacts => _artifacts;

        public bool HasArtifact(string artifactId)
        {
            if (string.IsNullOrWhiteSpace(artifactId)) return false;
            return _artifacts.Contains(artifactId);
        }

        public bool AddArtifact(string artifactId)
        {
            if (string.IsNullOrWhiteSpace(artifactId)) return false;
            return _artifacts.Add(artifactId);
        }

        public IReadOnlyDictionary<string, int> OreUnits => _oreUnits;

        public int GetUnits(string oreId)
            => _oreUnits.TryGetValue(oreId, out var u) ? u : 0;

        public void AddOreUnits(string oreId, int units)
        {
            if (units <= 0) return;

            if (_oreUnits.TryGetValue(oreId, out var existing))
                _oreUnits[oreId] = existing + units;
            else
                _oreUnits[oreId] = units;
        }
        public void ClearOreOnly()
        {
            _oreUnits.Clear();
        }

        /// <summary>
        /// Computes total credits for all stored ore using OreCatalog prices, then clears storage.
        /// Returns (creditsGained, stacksSold).
        /// Deterministic, single-pass, and centralizes sell logic.
        /// </summary>
        public (int creditsGained, int stacksSold) ComputeSaleValueAndClear()
        {
            if (_oreUnits.Count == 0)
                return (0, 0);

            int totalCredits = 0;
            int stacks = 0;

            foreach (var kv in _oreUnits)
            {
                int units = kv.Value;
                if (units <= 0) continue;

                int price = OreCatalog.BasePricePerUnit(kv.Key);
                totalCredits += units * price;
                stacks++;
            }

            ClearOreOnly();
            return (totalCredits, stacks);
        }

        public void LoadOreUnits(IEnumerable<MineIt.Save.StringIntPair> pairs)
        {
            ClearOreOnly();
            if (pairs == null) return;

            foreach (var p in pairs)
            {
                if (p == null || string.IsNullOrEmpty(p.Key) || p.Value <= 0) continue;
                AddOreUnits(p.Key, p.Value);
            }
        }

        public void LoadOreUnits(IDictionary<string, int> oreUnits)
        {
            ClearOreOnly();
            if (oreUnits == null) return;

            foreach (var kv in oreUnits)
            {
                if (kv.Value <= 0) continue;
                AddOreUnits(kv.Key, kv.Value);
            }
        }

        public void LoadArtifacts(System.Collections.Generic.IEnumerable<string> artifactIds)
        {
            _artifacts.Clear();
            if (artifactIds == null) return;

            foreach (var id in artifactIds)
            {
                if (string.IsNullOrWhiteSpace(id)) continue;
                _artifacts.Add(id);
            }
        }

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Inventory\UpgradeCatalog.cs =====
namespace MineIt.Inventory
{
    /// <summary>
    /// MVP upgrade pricing / capacities (later move into JSON or economy model).
    /// </summary>
    public static class UpgradeCatalog
    {
        public static int DetectorPriceForTier(int tier)
        {
            return tier switch
            {
                1 => 200,
                2 => 500,
                3 => 1200,
                4 => 2500,
                5 => 5000,
                _ => 0
            };
        }

        public static int ExtractorPriceForTier(int tier)
        {
            return tier switch
            {
                1 => 200,
                2 => 600,
                3 => 1500,
                4 => 3200,
                5 => 7000,
                _ => 0
            };
        }

        public static int BackpackPriceForTier(int tier)
        {
            // MVP tuning values (easy to adjust)
            return tier switch
            {
                1 => 0,
                2 => 300,
                3 => 800,
                4 => 1500,
                5 => 2500,
                _ => 0
            };
        }

        public static double BackpackCapacityKgForTier(int tier)
        {
            // Locked from your architecture doc
            return tier switch
            {
                1 => 50.0,
                2 => 100.0,
                3 => 200.0,
                4 => 350.0,
                5 => 500.0,
                _ => 50.0
            };
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Mining\Deposit.cs =====
namespace MineIt.Mining
{
    public sealed class Deposit
    {
        public int DepositId { get; internal set; }
        public string OreTypeId { get; internal set; } = "iron";

        // ===== Artifacts (core foundation) =====
        // If true, this deposit yields an artifact rather than normal ore.
        public bool IsArtifact { get; internal set; }

        // One of the 6 artifact IDs (e.g., "stellar_shard"). Empty if not artifact.
        public string ArtifactId { get; internal set; } = "";
        
        // ======================================
        public int CenterTx { get; internal set; }
        public int CenterTy { get; internal set; }

        public int DepthMeters { get; internal set; }
        public int SizeTier { get; internal set; }          // 1..15
        public int RemainingUnits { get; internal set; }

        public int? ClaimedByNpcId { get; internal set; }
        public bool ClaimedByPlayer { get; internal set; }

        public bool DiscoveredByPlayer { get; internal set; }

        /// <summary>
        /// Estimates time (in seconds) until this deposit is depleted,
        /// given an effective extraction rate (kg/sec).
        /// Returns double.PositiveInfinity if rate is zero or deposit already empty.
        /// </summary>
        public double EstimateSecondsToDeplete(double extractionRateKgPerSec)
        {
            if (RemainingUnits <= 0) return 0.0;
            if (extractionRateKgPerSec <= 1e-9) return double.PositiveInfinity;

            double unitKg = Inventory.OreCatalog.UnitMassKg(OreTypeId);
            if (unitKg <= 1e-9) unitKg = 1.0;

            double remainingKg = RemainingUnits * unitKg;
            return remainingKg / extractionRateKgPerSec;
        }

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Mining\DepositManager.cs =====
using System;
using System.Collections.Generic;
using MineIt.World;

namespace MineIt.Mining
{
    public sealed class DepositManager
    {
        private readonly int _seed;

        // Simple: keep discovered deposits in a dictionary by id for now
        private readonly Dictionary<int, Deposit> _allDeposits = new Dictionary<int, Deposit>();

        // ===== Artifacts (guaranteed deterministic spawns) =====
        private sealed class ArtifactSpawn
        {
            public string ArtifactId = "";
            public int DepositId;
            public int Tx;
            public int Ty;
            public int DepthMeters;
        }

        private readonly List<ArtifactSpawn> _artifactSpawns = new List<ArtifactSpawn>(6);

        // Canonical artifact IDs (stable)
        private static readonly string[] ArtifactIds =
        {
            "stellar_shard",
            "ancient_lattice",
            "void_compass",
            "quantum_fossil",
            "machine_relic",
            "echo_prism"
        };
        // ======================================================

        public DepositManager(int seed)
        {
            _seed = seed;
            BuildArtifactSpawnsDeterministic();
        }

        public IEnumerable<Deposit> GetAllDeposits() => _allDeposits.Values;

        /// <summary>
        /// Called when a chunk is first created/loaded.
        /// NOTE: townCenter is passed in to keep the signature aligned with your core architecture,
        /// even though the current town is always the center in your implementation.
        /// </summary>
        public void PopulateChunkDeposits(Chunk chunk, int townCenterTx, int townCenterTy)
        {
            // Deterministic per chunk
            int cx = chunk.Coord.Cx;
            int cy = chunk.Coord.Cy;

            int chunkSeed = ChunkSeed(cx, cy);
            var rng = new Random(chunkSeed);

            // Always materialize any precomputed artifacts that fall inside this chunk
            MaterializeArtifactsForChunk(chunk);

            // deposits per chunk (tuning constant)
            // TESTING: increase density so scans find something more often
            int count = rng.Next(3, 8); // 3..7 deposits per chunk
            for (int i = 0; i < count; i++)
            {
                int lx = rng.Next(0, Chunk.CHUNK_SIZE_TILES);
                int ly = rng.Next(0, Chunk.CHUNK_SIZE_TILES);

                int tx = cx * Chunk.CHUNK_SIZE_TILES + lx;
                int ty = cy * Chunk.CHUNK_SIZE_TILES + ly;

                int depth = rng.Next(30, 651);
                int tier = rng.Next(1, 16);
                string ore = PickOre(rng, depth);

                int units = BaseUnitsForTier(tier);

                int id = MakeDepositId(cx, cy, i);

                if (_allDeposits.ContainsKey(id))
                    continue;

                var d = new Deposit
                {
                    DepositId = id,
                    OreTypeId = ore,
                    CenterTx = tx,
                    CenterTy = ty,
                    DepthMeters = depth,
                    SizeTier = tier,
                    RemainingUnits = units,
                    DiscoveredByPlayer = false,

                    // artifacts (regular deposits are not artifacts)
                    IsArtifact = false,
                    ArtifactId = ""
                };

                AddOrReplaceDepositToChunk(chunk, d);
            }
        }

        public Deposit TryGetDepositById(int depositId)
        {
            _allDeposits.TryGetValue(depositId, out var d);
            return d;
        }

        public List<ScanResult> Scan(
            ChunkManager chunks,
            int scanCenterTx,
            int scanCenterTy,
            int radiusTiles,
            int maxDepthMeters,
            int sizeNoiseTiers,
            Random rng)
        {
            int minTx = scanCenterTx - radiusTiles;
            int maxTx = scanCenterTx + radiusTiles;
            int minTy = scanCenterTy - radiusTiles;
            int maxTy = scanCenterTy + radiusTiles;

            var minC = ChunkManager.TileToChunk(minTx, minTy);
            var maxC = ChunkManager.TileToChunk(maxTx, maxTy);

            int r2 = radiusTiles * radiusTiles;

            var results = new List<ScanResult>();

            for (int cy = minC.Cy; cy <= maxC.Cy; cy++)
                for (int cx = minC.Cx; cx <= maxC.Cx; cx++)
                {
                    Chunk ch;
                    try { ch = chunks.GetOrLoadChunk(cx, cy); }
                    catch { continue; }

                    foreach (var d in ch.Deposits)
                    {
                        if (d.RemainingUnits <= 0) continue;
                        if (d.DepthMeters > maxDepthMeters) continue;

                        int dx = d.CenterTx - scanCenterTx;
                        int dy = d.CenterTy - scanCenterTy;
                        if (dx * dx + dy * dy > r2) continue;

                        // Signal strength
                        double distTiles = System.Math.Sqrt(dx * dx + dy * dy);
                        double hd = distTiles / System.Math.Max(radiusTiles, 1);
                        double vd = (double)d.DepthMeters / System.Math.Max(maxDepthMeters, 1);

                        double sigBase = OreSignatureStrength(d.OreTypeId);
                        double sigSize = SigSizeFactor(d.SizeTier);

                        double strength = (sigBase * sigSize) / (1.0 + hd * hd + vd * vd);
                        int bars = SignalBarsFromStrength(strength);

                        // Size estimate noise (tier-based)
                        int estTier = d.SizeTier;
                        if (sizeNoiseTiers > 0)
                        {
                            int n = rng.Next(-sizeNoiseTiers, sizeNoiseTiers + 1);
                            estTier = System.Math.Clamp(d.SizeTier + n, 1, 15);
                        }

                        results.Add(new ScanResult
                        {
                            DepositId = d.DepositId,
                            OreTypeId = d.OreTypeId,
                            CenterTx = d.CenterTx,
                            CenterTy = d.CenterTy,
                            DepthMeters = d.DepthMeters,
                            TrueSizeTier = d.SizeTier,
                            EstimatedSizeTier = estTier,
                            EstimatedSizeClass = SizeClassFromTier(estTier),
                            SignalBars = bars
                        });
                    }
                }

            return results;
        }

        private int ChunkSeed(int cx, int cy)
        {
            unchecked
            {
                int h = 23;
                h = h * 31 + _seed;
                h = h * 31 + cx;
                h = h * 31 + cy;
                h ^= (h << 13);
                h ^= (h >> 17);
                h ^= (h << 5);
                return h;
            }
        }

        private static int MakeDepositId(int cx, int cy, int i)
        {
            unchecked
            {
                // 8 bits for cx (0..255), 8 bits for cy (0..255), 16 bits for i (0..65535)
                // Works perfectly for a 512x512 tile world with 32x32 chunks => 16x16 chunks.
                int cxb = cx & 0xFF;
                int cyb = cy & 0xFF;
                int ii = i & 0xFFFF;

                return (cxb) | (cyb << 8) | (ii << 16);
            }
        }

        private static int BaseUnitsForTier(int tier)
        {
            // MVP mapping (your earlier table)
            return tier switch
            {
                1 => 20,
                2 => 28,
                3 => 40,
                4 => 56,
                5 => 80,
                6 => 112,
                7 => 160,
                8 => 224,
                9 => 320,
                10 => 448,
                11 => 640,
                12 => 896,
                13 => 1280,
                14 => 1792,
                15 => 2560,
                _ => 80
            };
        }

        private static string PickOre(Random rng, int depthMeters)
        {
            // MVP heuristic: deeper => rarer
            int roll = rng.Next(100);

            if (depthMeters >= 600)
                return roll < 3 ? "aether" : (roll < 10 ? "xenon" : "plat");

            if (depthMeters >= 450)
                return roll < 10 ? "gold" : (roll < 35 ? "cobalt" : "titanium");

            if (depthMeters >= 250)
                return roll < 15 ? "lithium" : (roll < 40 ? "alum" : "quartz");

            return roll < 45 ? "iron" : "copper";
        }

        private static double OreSignatureStrength(string oreId)
        {
            // MVP defaults (later: from ores.json)
            return oreId switch
            {
                // Artifacts: strong signature so they rank highly and are easy to notice once in range
                "artifact" => 2.2,

                "scrap" => 0.8,
                "iron" => 1.0,
                "copper" => 1.0,
                "quartz" => 1.1,
                "alum" => 1.05,
                "lithium" => 1.15,
                "titanium" => 1.2,
                "cobalt" => 1.25,
                "neodym" => 1.3,
                "gold" => 1.2,
                "plat" => 1.35,
                "xenon" => 1.45,
                "aether" => 1.55,
                _ => 1.0
            };
        }

        private static double SigSizeFactor(int sizeTier)
        {
            // sigSize = 1 + 0.08*log2(SizeTier+1)
            // (mild size effect)
            double v = sizeTier + 1;
            double log2 = System.Math.Log(v, 2.0);
            return 1.0 + 0.08 * log2;
        }

        private static int SignalBarsFromStrength(double s)
        {
            // Map to 1..5 (tune later)
            if (s >= 1.20) return 5;
            if (s >= 0.85) return 4;
            if (s >= 0.60) return 3;
            if (s >= 0.40) return 2;
            return 1;
        }

        private static string SizeClassFromTier(int tier)
        {
            // Simple buckets for UI (tune later)
            if (tier <= 5) return "Small";
            if (tier <= 10) return "Medium";
            return "Large";
        }

        public void AddOrReplaceDepositToChunk(Chunk chunk, Deposit d)
        {
            // Replace in manager dictionary
            _allDeposits[d.DepositId] = d;

            // Replace in chunk list (by id) — CORE-ONLY mutable access
            var list = chunk.DepositsMutable;

            for (int i = 0; i < list.Count; i++)
            {
                if (list[i].DepositId == d.DepositId)
                {
                    list[i] = d;
                    return;
                }
            }

            // Not found → add
            list.Add(d);
        }

        // ===== Artifacts (guaranteed deterministic spawns) =====

        private void BuildArtifactSpawnsDeterministic()
        {
            _artifactSpawns.Clear();

            var rng = new Random(_seed ^ 0x6B9D2E17);

            const int townTx = MineIt.Simulation.GameSession.WORLD_W_TILES / 2;
            const int townTy = MineIt.Simulation.GameSession.WORLD_H_TILES / 2;

            for (int i = 0; i < ArtifactIds.Length; i++)
            {
                string artifactId = ArtifactIds[i];

                int tx, ty;

                // Guaranteed Band-4 selection
                for (; ; )
                {
                    tx = rng.Next(0, MineIt.Simulation.GameSession.WORLD_W_TILES);
                    ty = rng.Next(0, MineIt.Simulation.GameSession.WORLD_H_TILES);

                    if (ComputeRegionBand(tx, ty, townTx, townTy) == 4)
                        break;
                }

                int depth = rng.Next(450, 651);

                _artifactSpawns.Add(new ArtifactSpawn
                {
                    ArtifactId = artifactId,
                    DepositId = MakeArtifactDepositId(i, tx, ty),
                    Tx = tx,
                    Ty = ty,
                    DepthMeters = depth
                });
            }
        }

        private void MaterializeArtifactsForChunk(Chunk chunk)
        {
            if (_artifactSpawns.Count == 0) return;

            int cx = chunk.Coord.Cx;
            int cy = chunk.Coord.Cy;

            int baseTx = cx * Chunk.CHUNK_SIZE_TILES;
            int baseTy = cy * Chunk.CHUNK_SIZE_TILES;
            int endTx = baseTx + Chunk.CHUNK_SIZE_TILES - 1;
            int endTy = baseTy + Chunk.CHUNK_SIZE_TILES - 1;

            for (int i = 0; i < _artifactSpawns.Count; i++)
            {
                var a = _artifactSpawns[i];

                if (a.Tx < baseTx || a.Tx > endTx || a.Ty < baseTy || a.Ty > endTy)
                    continue;

                // Already created?
                if (_allDeposits.ContainsKey(a.DepositId))
                    continue;

                var d = new Deposit
                {
                    DepositId = a.DepositId,
                    OreTypeId = "artifact",
                    CenterTx = a.Tx,
                    CenterTy = a.Ty,
                    DepthMeters = a.DepthMeters,
                    SizeTier = 15,
                    RemainingUnits = 1,

                    DiscoveredByPlayer = false,

                    IsArtifact = true,
                    ArtifactId = a.ArtifactId
                };

                AddOrReplaceDepositToChunk(chunk, d);
            }
        }

        private static int MakeArtifactDepositId(int index0to5, int tx, int ty)
        {
            // High-bit namespace to avoid collisions with MakeDepositId()
            unchecked
            {
                int idx = index0to5 & 0x7;  // 3 bits
                int x = tx & 0x1FF;         // 9 bits (0..511)
                int y = ty & 0x1FF;         // 9 bits (0..511)

                return (0x7 << 28) | (idx << 18) | (x << 9) | y;
            }
        }

        private static int ComputeRegionBand(int tx, int ty, int townTx, int townTy)
        {
            int dx = tx - townTx;
            int dy = ty - townTy;

            // Euclidean tile distance rounded to int
            int d = (int)Math.Round(Math.Sqrt(dx * dx + dy * dy));

            if (d <= 40) return 0;
            if (d <= 120) return 1;
            if (d <= 220) return 2;
            if (d <= 320) return 3;
            return 4;
        }

        // ===== Debug/Presentation accessors for artifact spawns =====
        // Unity-side debug map overlay needs coordinates; keep it read-only.

        public int GetArtifactSpawnCount()
        {
            return (_artifactSpawns != null) ? _artifactSpawns.Count : 0;
        }

        public bool TryGetArtifactSpawn(int index,
            out string artifactId,
            out int tx,
            out int ty,
            out int depthMeters,
            out int depositId)
        {
            artifactId = "";
            tx = ty = depthMeters = depositId = 0;

            if (_artifactSpawns == null) return false;
            if ((uint)index >= (uint)_artifactSpawns.Count) return false;

            var a = _artifactSpawns[index];
            if (a == null) return false;

            artifactId = a.ArtifactId ?? "";
            tx = a.Tx;
            ty = a.Ty;
            depthMeters = a.DepthMeters;
            depositId = a.DepositId;
            return true;
        }
        // ==========================================================


        // ======================================================

        public string GetArtifactSpawnsDebugReport()
        {
            int idsLen = (ArtifactIds != null) ? ArtifactIds.Length : -1;
            int spawns = (_artifactSpawns != null) ? _artifactSpawns.Count : -1;

            var sb = new System.Text.StringBuilder(1024);

            sb.Append("Artifacts DEBUG: ArtifactIds.Length=")
              .Append(idsLen)
              .Append("  _artifactSpawns.Count=")
              .Append(spawns)
              .AppendLine();

            if (_artifactSpawns == null || _artifactSpawns.Count == 0)
            {
                sb.AppendLine("Artifacts: (none precomputed)");
                return sb.ToString();
            }

            sb.AppendLine("Artifacts (precomputed, deterministic):");

            int townTx = MineIt.Simulation.GameSession.WORLD_W_TILES / 2;
            int townTy = MineIt.Simulation.GameSession.WORLD_H_TILES / 2;

            for (int i = 0; i < _artifactSpawns.Count; i++)
            {
                var a = _artifactSpawns[i];
                if (a == null) continue;

                int dx = a.Tx - townTx;
                int dy = a.Ty - townTy;
                double dist = Math.Sqrt(dx * dx + dy * dy);

                int cx = a.Tx / MineIt.World.Chunk.CHUNK_SIZE_TILES;
                int cy = a.Ty / MineIt.World.Chunk.CHUNK_SIZE_TILES;

                sb.Append(" ")
                  .Append(i + 1).Append(") ")
                  .Append(a.ArtifactId)
                  .Append("  id=").Append(a.DepositId)
                  .Append("  tile=(").Append(a.Tx).Append(",").Append(a.Ty).Append(')')
                  .Append("  chunk=(").Append(cx).Append(",").Append(cy).Append(')')
                  .Append("  depth=").Append(a.DepthMeters).Append("m")
                  .Append("  dist=").Append(dist.ToString("0.0"))
                  .AppendLine();
            }

            return sb.ToString();
        }

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Mining\NpcMinerManager.cs =====
using System;
using System.Collections.Generic;
using MineIt.Inventory;
using MineIt.World;

namespace MineIt.Mining
{
    /// <summary>
    /// Phase 1 NPC miners (headless simulation):
    /// - No movement / no pathfinding
    /// - Claim + extract deposits over time
    /// - Deterministic based on seed and internal RNG
    /// - Operates only on deposits that exist in DepositManager (i.e., populated chunks)
    /// </summary>
    public sealed class NpcMinerManager
    {
        public sealed class NpcMiner
        {
            public int NpcId;
            public int Tier; // 1..5 (simple skill/perf scalar)

            // Current target deposit id (0 = none)
            public int TargetDepositId;

            // Time until next decision attempt (seconds)
            public double DecisionCooldownRemainingSeconds;

            // Deterministic per-NPC stagger
            public double DecisionCooldownMinSeconds;
            public double DecisionCooldownMaxSeconds;

            // Extract carry (kg) to avoid fractional loss like player extractor
            public double ExtractKgCarry;
        }

        private readonly int _seed;
        private readonly Random _rng;
        private readonly List<NpcMiner> _npcs = new List<NpcMiner>();

        public IReadOnlyList<NpcMiner> Npcs => _npcs;

        public int NpcCount => _npcs.Count;

        public NpcMinerManager(int seed)
        {
            _seed = seed;
            _rng = new Random(seed ^ 0x19C4A33D);
        }

        public void InitializeMvpNpcSet(int count)
        {
            _npcs.Clear();

            count = Math.Max(0, count);

            for (int i = 0; i < count; i++)
            {
                // Deterministic tier assignment (simple)
                int tier = 1 + (i % 5);

                // Stagger decisions so they don't all spike same tick
                double min = 3.0;
                double max = 6.0;

                var npc = new NpcMiner
                {
                    NpcId = i + 1, // 1..N
                    Tier = tier,
                    TargetDepositId = 0,
                    DecisionCooldownMinSeconds = min,
                    DecisionCooldownMaxSeconds = max,
                    DecisionCooldownRemainingSeconds = NextDecisionDelay(min, max),
                    ExtractKgCarry = 0.0
                };

                _npcs.Add(npc);
            }
        }

        public void Tick(double dtSeconds, DepositManager deposits)
        {
            if (dtSeconds <= 0) return;
            if (deposits == null) return;
            if (_npcs.Count == 0) return;

            for (int i = 0; i < _npcs.Count; i++)
            {
                var npc = _npcs[i];

                // If has target, extract; else decide
                if (npc.TargetDepositId != 0)
                {
                    TickExtraction(dtSeconds, deposits, npc);
                }
                else
                {
                    TickDecision(dtSeconds, deposits, npc);
                }
            }
        }

        private void TickDecision(double dtSeconds, DepositManager deposits, NpcMiner npc)
        {
            npc.DecisionCooldownRemainingSeconds -= dtSeconds;
            if (npc.DecisionCooldownRemainingSeconds > 0)
                return;

            npc.DecisionCooldownRemainingSeconds = NextDecisionDelay(npc.DecisionCooldownMinSeconds, npc.DecisionCooldownMaxSeconds);

            // Attempt to claim a deposit.
            // Phase 1 rule: choose "best" available among known deposits:
            // - unclaimed
            // - has remaining units
            // - not player-claimed
            // Choose by a simple score: (rarer/deeper slightly preferred + larger preferred)
            int bestId = 0;
            double bestScore = double.NegativeInfinity;

            foreach (var d in deposits.GetAllDeposits())
            {
                if (d == null) continue;
                if (d.RemainingUnits <= 0) continue;
                if (d.IsArtifact) continue; // locked fairness rule: NPCs never claim artifact deposits

                if (d.ClaimedByPlayer) continue;
                if (d.ClaimedByNpcId.HasValue) continue;

                // Prefer larger and deeper slightly (creates pressure on valuable deposits)
                double score = 0.0;
                score += d.SizeTier * 1.0;
                score += (d.DepthMeters / 100.0) * 0.25;

                // Small deterministic jitter so ties break without bias to iteration order
                score += (_rng.NextDouble() * 0.05);

                if (score > bestScore)
                {
                    bestScore = score;
                    bestId = d.DepositId;
                }
            }

            if (bestId == 0)
                return;

            var target = deposits.TryGetDepositById(bestId);
            if (target == null) return;

            // Re-check eligibility and claim
            if (target.RemainingUnits <= 0) return;
            if (target.ClaimedByPlayer) return;
            if (target.ClaimedByNpcId.HasValue) return;

            target.ClaimedByNpcId = npc.NpcId;
            // DEBUG: force discovery so NPC activity is visible on map
            //target.DiscoveredByPlayer = true;

            npc.TargetDepositId = bestId;
            npc.ExtractKgCarry = 0.0;

        }

        private void TickExtraction(double dtSeconds, DepositManager deposits, NpcMiner npc)
        {
            var d = deposits.TryGetDepositById(npc.TargetDepositId);
            if (d == null)
            {
                npc.TargetDepositId = 0;
                npc.ExtractKgCarry = 0.0;
                return;
            }

            // Safety: NPCs should never extract artifacts
            if (d.IsArtifact)
            {
                npc.TargetDepositId = 0;
                npc.ExtractKgCarry = 0.0;
                return;
            }

            // If deposit is depleted or ownership changed, release target
            if (d.RemainingUnits <= 0)
            {
                d.RemainingUnits = 0;
                npc.TargetDepositId = 0;
                npc.ExtractKgCarry = 0.0;
                return;
            }

            if (d.ClaimedByPlayer)
            {
                // Player owns it now (future-proof: should not happen in Phase 1)
                npc.TargetDepositId = 0;
                npc.ExtractKgCarry = 0.0;
                return;
            }

            if (!d.ClaimedByNpcId.HasValue || d.ClaimedByNpcId.Value != npc.NpcId)
            {
                // Lost ownership
                npc.TargetDepositId = 0;
                npc.ExtractKgCarry = 0.0;
                return;
            }

            // Extract rate: slower than player, scaled by tier, affected by ore difficulty
            double baseRateKgPerSec = 0.25 + (npc.Tier - 1) * 0.20; // Tier1=0.25, Tier5=1.05
            double diff = OreCatalog.ExtractionDifficulty(d.OreTypeId);
            if (diff < 1e-6) diff = 1.0;

            double rateKgPerSec = baseRateKgPerSec / diff;
            if (rateKgPerSec < 1e-6) rateKgPerSec = 1e-6;

            double kgThisTick = rateKgPerSec * dtSeconds;

            double unitKg = OreCatalog.UnitMassKg(d.OreTypeId);
            if (unitKg < 1e-6) unitKg = 1.0;

            npc.ExtractKgCarry += kgThisTick;

            int unitsPotential = (int)Math.Floor(npc.ExtractKgCarry / unitKg);
            if (unitsPotential <= 0)
                return;

            int unitsByDeposit = Math.Min(unitsPotential, d.RemainingUnits);
            if (unitsByDeposit <= 0)
                return;

            d.RemainingUnits -= unitsByDeposit;

            npc.ExtractKgCarry -= unitsByDeposit * unitKg;
            if (npc.ExtractKgCarry < 0) npc.ExtractKgCarry = 0;

            if (d.RemainingUnits <= 0)
            {
                d.RemainingUnits = 0;
                npc.TargetDepositId = 0;
                npc.ExtractKgCarry = 0.0;
            }
        }

        private double NextDecisionDelay(double min, double max)
        {
            if (max <= min) return Math.Max(0.1, min);
            return min + _rng.NextDouble() * (max - min);
        }

        public double GetNpcExtractionRateKgPerSec(NpcMiner npc, string oreTypeId)
        {
            if (npc == null) return 0.0;

            double baseRateKgPerSec = 0.25 + (npc.Tier - 1) * 0.20;
            double diff = Inventory.OreCatalog.ExtractionDifficulty(oreTypeId);
            if (diff < 1e-6) diff = 1.0;

            return baseRateKgPerSec / diff;
        }

        // ===== Save/Load support =====

        public void LoadFromSave(List<MineIt.Save.NpcMinerSaveData> list)
        {
            if (list == null) return;

            _npcs.Clear();

            for (int i = 0; i < list.Count; i++)
            {
                var sd = list[i];
                if (sd == null) continue;

                var npc = new NpcMiner
                {
                    NpcId = sd.NpcId,
                    Tier = sd.Tier,
                    TargetDepositId = sd.TargetDepositId,
                    DecisionCooldownRemainingSeconds = sd.DecisionCooldownRemainingSeconds,
                    DecisionCooldownMinSeconds = sd.DecisionCooldownMinSeconds,
                    DecisionCooldownMaxSeconds = sd.DecisionCooldownMaxSeconds,
                    ExtractKgCarry = sd.ExtractKgCarry
                };

                _npcs.Add(npc);
            }
        }

        public void SaveTo(List<MineIt.Save.NpcMinerSaveData> outList)
        {
            if (outList == null) return;

            outList.Clear();

            for (int i = 0; i < _npcs.Count; i++)
            {
                var npc = _npcs[i];
                outList.Add(new MineIt.Save.NpcMinerSaveData
                {
                    NpcId = npc.NpcId,
                    Tier = npc.Tier,
                    TargetDepositId = npc.TargetDepositId,
                    DecisionCooldownRemainingSeconds = npc.DecisionCooldownRemainingSeconds,
                    DecisionCooldownMinSeconds = npc.DecisionCooldownMinSeconds,
                    DecisionCooldownMaxSeconds = npc.DecisionCooldownMaxSeconds,
                    ExtractKgCarry = npc.ExtractKgCarry
                });
            }
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Mining\ScanResult.cs =====
namespace MineIt.Mining
{
    public sealed class ScanResult
    {
        public int DepositId { get; set; }
        public string OreTypeId { get; set; } = "";
        public int CenterTx { get; set; }
        public int CenterTy { get; set; }

        public int TrueSizeTier { get; set; }
        public int EstimatedSizeTier { get; set; }
        public string EstimatedSizeClass { get; set; } = "Unknown";

        public int DepthMeters { get; set; }
        public int SignalBars { get; set; }

        /// <summary>
        /// Computes a priority score for decision-making and UI sorting.
        /// Higher score = higher urgency / value.
        /// This does NOT affect simulation; UI-only guidance.
        /// </summary>
        public double ComputePriorityScore()
        {
            double score = 0.0;

            // Signal confidence (1..5)
            score += SignalBars * 10.0;

            // Size (estimated)
            score += EstimatedSizeTier * 2.0;

            // Depth penalty (shallower is better)
            score -= (DepthMeters / 50.0);

            return score;
        }

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Models\PlayerState.cs =====
namespace MineIt.Models
{
    public sealed class PlayerState
    {
        // World coordinates in tile units (smooth movement).
        public double PositionX { get; set; }
        public double PositionY { get; set; }

        public double MoveSpeedTilesPerSec { get; set; } = 6.0;

        // MVP detector (Tier 1 defaults)
        public int DetectorTier { get; set; } = 1;

        // MVP extractor (Tier 1 defaults) - NEW
        public int ExtractorTier { get; set; } = 1;

        public int ExtractorMaxDepthMeters =>
            ExtractorTier switch
            {
                1 => 100,
                2 => 200,
                3 => 350,
                4 => 500,
                5 => 650,
                _ => 100
            };

        public double ExtractorRateKgPerSec =>
            ExtractorTier switch
            {
                1 => 0.5,
                2 => 1.0,
                3 => 2.0,
                4 => 4.0,
                5 => 8.0,
                _ => 0.5
            };

        public int ExtractorRangeTiles =>
            ExtractorTier switch
            {
                1 => 3,
                2 => 3,
                3 => 4,
                4 => 4,
                5 => 5,
                _ => 3
            };

        public int DetectorMaxDepthMeters =>
            DetectorTier switch
            {
                1 => 100,
                2 => 200,
                3 => 350,
                4 => 500,
                5 => 650,
                _ => 100
            };

        public int DetectorRadiusTiles =>
            DetectorTier switch
            {
                1 => 4,
                2 => 6,
                3 => 8,
                4 => 10,
                5 => 12,
                _ => 4
            };

        // Locked cooldown table (seconds)
        public double DetectorCooldownSeconds =>
            DetectorTier switch
            {
                1 => 2.0,
                2 => 2.0,
                3 => 1.8,
                4 => 1.6,
                5 => 1.4,
                _ => 2.0
            };

        // Locked size estimate noise (tiers)
        public int DetectorSizeNoiseTiers =>
            DetectorTier switch
            {
                1 => 2,
                2 => 2,
                3 => 1,
                4 => 1,
                5 => 0,
                _ => 2
            };
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Save\SaveData.cs =====
using System;
using System.Collections.Generic;

namespace MineIt.Save
{
    [Serializable]
    public sealed class SaveGameData
    {
        public int Version = 1;

        public int Seed;
        public double TotalRealSeconds;

        public PlayerSaveData Player = new PlayerSaveData();

        public bool HasWon;

        public bool VaultAuthInProgress;
        public double VaultAuthRemainingSeconds;

        // JsonUtility can't do Dictionary<,> -> store as pairs
        public List<StringIntPair> BackpackOre = new List<StringIntPair>();
        public List<StringIntPair> TownOre = new List<StringIntPair>();

        // Artifacts are unique quest items (IDs). Stored separately from ore.
        public List<string> BackpackArtifacts = new List<string>();
        public List<string> TownArtifacts = new List<string>();

        public List<DepositSaveData> Deposits = new List<DepositSaveData>();
        public List<NpcMinerSaveData> NpcMiners = new List<NpcMinerSaveData>();

        // Base64 of uint[] discovered bitset
        public string FogDiscoveredBitsBase64 = "";

        // ===== Waypoint persistence (Unity-owned state, saved here) =====
        public bool HasWaypoint;
        public int WaypointTx;
        public int WaypointTy;
    }

    [Serializable]
    public sealed class NpcMinerSaveData
    {
        public int NpcId;
        public int Tier;

        public int TargetDepositId;

        public double DecisionCooldownRemainingSeconds;
        public double DecisionCooldownMinSeconds;
        public double DecisionCooldownMaxSeconds;

        public double ExtractKgCarry;
    }


    [Serializable]
    public sealed class PlayerSaveData
    {
        public double PositionX;
        public double PositionY;

        public int DetectorTier;
        public int ExtractorTier;

        public int BackpackTier;
        public int Credits;
    }

    [Serializable]
    public sealed class DepositSaveData
    {
        public int DepositId;
        public int RemainingUnits;

        // Artifacts
        public bool IsArtifact;
        public string ArtifactId;

        public bool ClaimedByPlayer;

        // JsonUtility can't do nullable int -> -1 means none
        public int ClaimedByNpcId;

        public bool DiscoveredByPlayer;
    }

    [Serializable]
    public sealed class StringIntPair
    {
        public string Key;
        public int Value;

        public StringIntPair(string key, int value) { Key = key; Value = value; }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Save\SaveGameSerializer.cs =====
using System;
using MineIt.Simulation;
using UnityEngine; // JsonUtility

namespace MineIt.Save
{
    public static class SaveGameSerializer
    {
        public static SaveGameData SaveToData(GameSession s)
        {
            if (s == null) throw new ArgumentNullException(nameof(s));

            var data = new SaveGameData
            {
                Version = 2, // bumped because format added waypoint fields
                Seed = s.Seed,
                TotalRealSeconds = s.Clock.TotalRealSeconds
            };

            // Player
            data.Player.PositionX = s.Player.PositionX;
            data.Player.PositionY = s.Player.PositionY;
            data.Player.DetectorTier = s.Player.DetectorTier;
            data.Player.ExtractorTier = s.Player.ExtractorTier;
            data.Player.BackpackTier = s.BackpackTier;
            data.Player.Credits = s.Credits;

            data.HasWon = s.HasWon;
            data.VaultAuthInProgress = s.VaultAuthInProgress;
            data.VaultAuthRemainingSeconds = s.VaultAuthRemainingSeconds;


            // Inventory (pairs)
            data.BackpackOre.Clear();
            if (s.Backpack != null)
            {
                foreach (var kv in s.Backpack.OreUnits)
                    data.BackpackOre.Add(new StringIntPair(kv.Key, kv.Value));
            }

            data.BackpackArtifacts.Clear();
            if (s.Backpack != null)
            {
                foreach (var aid in s.Backpack.Artifacts)
                    data.BackpackArtifacts.Add(aid);
            }

            data.TownOre.Clear();
            if (s.TownStorage != null)
            {
                foreach (var kv in s.TownStorage.OreUnits)
                    data.TownOre.Add(new StringIntPair(kv.Key, kv.Value));
            }

            data.TownArtifacts.Clear();
            if (s.TownStorage != null)
            {
                foreach (var aid in s.TownStorage.Artifacts)
                    data.TownArtifacts.Add(aid);
            }

            // Deposits (mutable deltas)
            data.Deposits.Clear();
            foreach (var d in s.Deposits.GetAllDeposits())
            {
                data.Deposits.Add(new DepositSaveData
                {
                    DepositId = d.DepositId,
                    RemainingUnits = d.RemainingUnits,

                    // Artifacts
                    IsArtifact = d.IsArtifact,
                    ArtifactId = d.ArtifactId,

                    ClaimedByPlayer = d.ClaimedByPlayer,
                    ClaimedByNpcId = d.ClaimedByNpcId.HasValue ? d.ClaimedByNpcId.Value : -1,
                    DiscoveredByPlayer = d.DiscoveredByPlayer
                });
            }

            // NPC miners (Phase 1)
            data.NpcMiners.Clear();
            if (s.Npcs != null)
            {
                s.Npcs.SaveTo(data.NpcMiners);
            }

            // Fog discovered bits (uint[] -> byte[] -> base64)
            var bits = s.Fog.CopyDiscoveredBits();
            byte[] bytes = new byte[bits.Length * sizeof(uint)];
            Buffer.BlockCopy(bits, 0, bytes, 0, bytes.Length);
            data.FogDiscoveredBitsBase64 = Convert.ToBase64String(bytes);

            return data;
        }

        public static string ToJson(SaveGameData data, bool prettyPrint = true)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            return JsonUtility.ToJson(data, prettyPrint: prettyPrint);
        }

        // Back-compat wrapper (existing callers still work)
        public static string SaveToJson(GameSession s)
        {
            var data = SaveToData(s);
            return ToJson(data, prettyPrint: true);
        }

        public static SaveGameData LoadFromJson(string json)
        {
            if (string.IsNullOrWhiteSpace(json))
                throw new ArgumentException("Empty save json", nameof(json));

            var data = JsonUtility.FromJson<SaveGameData>(json);
            if (data == null) throw new InvalidOperationException("Failed to deserialize save data.");
            return data;
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Simulation\GameClock.cs =====
namespace MineIt.Simulation
{
    public sealed class GameClock
    {
        // Real-time seconds accumulated by simulation.
        public double TotalRealSeconds { get; private set; }

        // Locked: 1 full in-game day = 24 minutes real time.
        // 24 minutes = 1440 real seconds.
        public const double RealSecondsPerInGameDay = 24.0 * 60.0;

        // In-game time = 24 hours => 1440 minutes.
        public double DayFraction01
        {
            get
            {
                double t = TotalRealSeconds % RealSecondsPerInGameDay;
                return t / RealSecondsPerInGameDay; // 0..1
            }
        }

        public double InGameHours => DayFraction01 * 24.0;

        // Simple night definition: night is [20:00..24:00) U [0:00..6:00)
        public bool IsNight
        {
            get
            {
                double h = InGameHours;
                return (h >= 20.0) || (h < 6.0);
            }
        }

        // Darkness strength 0..1 with ramps at dusk/dawn.
        // Dusk: 18->20 ramps up. Dawn: 6->8 ramps down.
        public double Darkness01
        {
            get
            {
                double h = InGameHours;

                if (h >= 20.0 || h < 6.0) return 1.0;

                if (h >= 18.0 && h < 20.0)
                {
                    // 18..20 => 0..1
                    return (h - 18.0) / 2.0;
                }

                if (h >= 6.0 && h < 8.0)
                {
                    // 6..8 => 1..0
                    return 1.0 - ((h - 6.0) / 2.0);
                }

                return 0.0;
            }
        }

        public void Advance(double dtSeconds)
        {
            if (dtSeconds <= 0) return;
            TotalRealSeconds += dtSeconds;
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\Simulation\GameSession.cs =====
using System;
using System.Collections.Generic;
using MineIt.Fog;
using MineIt.Input;
using MineIt.Mining;
using MineIt.Models;
using MineIt.World;
using MineIt.Inventory; // NEW

namespace MineIt.Simulation
{
    public sealed class GameSession
    {
        // World constants (MVP)
        public const int WORLD_W_TILES = 512;
        public const int WORLD_H_TILES = 512;

        public GameClock Clock { get; } = new GameClock();
        public PlayerState Player { get; } = new PlayerState();

        public ChunkManager Chunks { get; private set; } = null!;
        public FogOfWar Fog { get; private set; } = null!;
        public DepositManager Deposits { get; private set; } = null!;

        public NpcMinerManager Npcs { get; private set; } = null!;

        // MVP tuning: start small; you can raise later
        public int NpcMinerCount { get; set; } = 12;

        // ===== Vault Authentication (Win gating) =====
        public bool HasWon { get; private set; }

        public bool VaultAuthInProgress { get; private set; }
        public double VaultAuthRemainingSeconds { get; private set; }

        // Tuning: how long the Vault takes to authenticate once all 6 are deposited
        public const double VaultAuthTotalSeconds = 10.0;
        // ============================================


        // ===== Inventory (NEW - MVP) =====
        public Backpack Backpack { get; private set; } = null!;

        public int BackpackTier { get; private set; } = 1; // NEW: track tier explicitly


        public int Credits { get; private set; }   // NEW
        /// <summary>
        /// Attempts to spend credits. Returns true if successful.
        /// </summary>
        public bool TrySpendCredits(int amount)
        {
            if (amount <= 0)
                return true;

            if (Credits < amount)
                return false;

            Credits -= amount;
            return true;
        }

        /// <summary>
        /// Adds credits (use for rewards, sales, etc).
        /// </summary>
        public void AddCredits(int amount)
        {
            if (amount <= 0)
                return;

            Credits += amount;
        }

        // ===== Town actions (sanctioned methods Unity UI may call) =====

        public bool TryDepositBackpackToTown(out int movedStacks)
        {
            movedStacks = 0;

            if (!IsInTownZone)
            {
                PostStatus("DEPOSIT FAILED (not in town)", 1.5);
                return false;
            }

            movedStacks = Backpack.TransferAllTo(TownStorage);

            PostStatus(movedStacks > 0 ? "DEPOSIT OK" : "DEPOSIT (nothing)", 1.5);
            return true;
        }

        public bool TrySellTownOre(out int creditsGained, out int stacksSold)
        {
            creditsGained = 0;
            stacksSold = 0;

            if (!IsInTownZone)
            {
                PostStatus("SELL FAILED (not in town)", 1.5);
                return false;
            }

            var result = TownStorage.ComputeSaleValueAndClear();
            creditsGained = result.creditsGained;
            stacksSold = result.stacksSold;

            if (creditsGained > 0)
            {
                Credits += creditsGained;
                PostStatus($"SOLD {stacksSold} STACKS  +{creditsGained} cr", 1.5);
                return true;
            }

            PostStatus("SELL (nothing)", 1.5);
            return true;
        }

        public bool TryBuyDetectorTier(int desiredTier)
        {
            if (!IsInTownZone)
            {
                PostStatus("UPGRADE BLOCKED (not in town)", 1.5);
                return false;
            }

            if (desiredTier <= Player.DetectorTier)
                return false;

            int cost = MineIt.Inventory.UpgradeCatalog.DetectorPriceForTier(desiredTier);
            if (Credits < cost)
            {
                PostStatus($"NEED {cost} cr for Detector T{desiredTier}", 1.5);
                return false;
            }

            Credits -= cost;
            Player.DetectorTier = desiredTier;
            PostStatus($"BOUGHT Detector T{desiredTier}  -{cost} cr", 1.5);
            return true;
        }

        public bool TryBuyExtractorTier(int desiredTier)
        {
            if (!IsInTownZone)
            {
                PostStatus("UPGRADE BLOCKED (not in town)", 1.5);
                return false;
            }

            if (desiredTier <= Player.ExtractorTier)
                return false;

            int cost = MineIt.Inventory.UpgradeCatalog.ExtractorPriceForTier(desiredTier);
            if (Credits < cost)
            {
                PostStatus($"NEED {cost} cr for Extractor T{desiredTier}", 1.5);
                return false;
            }

            Credits -= cost;
            Player.ExtractorTier = desiredTier;
            PostStatus($"BOUGHT Extractor T{desiredTier}  -{cost} cr", 1.5);
            return true;
        }

        public bool TryBuyBackpackTier(int desiredTier)
        {
            if (!IsInTownZone)
            {
                PostStatus("UPGRADE BLOCKED (not in town)", 1.5);
                return false;
            }

            if (desiredTier <= BackpackTier)
                return false;

            int cost = MineIt.Inventory.UpgradeCatalog.BackpackPriceForTier(desiredTier);
            if (Credits < cost)
            {
                PostStatus($"NEED {cost} cr for Backpack T{desiredTier}", 1.5);
                return false;
            }

            Credits -= cost;
            BackpackTier = desiredTier;

            double cap = MineIt.Inventory.UpgradeCatalog.BackpackCapacityKgForTier(desiredTier);
            Backpack.CapacityKg = System.Math.Max(cap, Backpack.CurrentKg);

            PostStatus($"BOUGHT Backpack T{desiredTier} ({Backpack.CapacityKg:0}kg)  -{cost} cr", 1.5);
            return true;
        }



        public TownStorage TownStorage { get; private set; } = null!;

        // Temporary town definition (MVP):
        public int TownCenterTx { get; private set; }
        public int TownCenterTy { get; private set; }
        public int TownRadiusTiles { get; private set; } = 10;

        // HUD helper
        public bool IsInTownZone { get; private set; }

        // ===== Extraction (NEW) =====
        public bool ExtractInProgress => _extractTargetDepositId != 0;

        public int ExtractTargetDepositId => _extractTargetDepositId;
        public double ExtractKgRemainder { get; private set; } // carried between ticks to avoid loss

        // HUD prompt info (computed each frame)
        public bool CanExtractNow { get; private set; }
        public int ExtractCandidateDepositId { get; private set; } // 0 if none
        public int ExtractCandidateTx { get; private set; }
        public int ExtractCandidateTy { get; private set; }


        // Active radius around camera (chunks)
        public int ActiveChunkRadius { get; set; } = 3;

        // ===== UI feedback events (WPF subscribes; core remains audio-agnostic) =====
        public event Action ScanExecuted;   // fires ONLY when scan actually runs
        public event Action ScanDud;        // fires when scan pressed but blocked (cooldown)
        public event Action ClaimSucceeded; // fires ONLY when claim completes successfully
        public event Action ClaimFailed;    // fires when claim cannot be started / is canceled / etc.
        public event Action VictoryAchieved;

        // ===== Scan debug / HUD fields =====
        public List<ScanResult> LastScanResults { get; private set; } = new List<ScanResult>();

        // Scan ring flash
        public double LastScanFlashSeconds { get; private set; }
        public int LastScanCenterTx { get; private set; }
        public int LastScanCenterTy { get; private set; }
        public int LastScanRadiusTiles { get; private set; }

        // Scan cooldown
        public double ScanCooldownRemainingSeconds { get; private set; }
        public double ScanCooldownMaxSeconds => Player.DetectorCooldownSeconds;

        // ===== Claim prompt + channel (NEW) =====
        public const double ClaimChannelTotalSeconds = 3.0;

        // True while channeling
        public bool ClaimInProgress => _claimTargetDepositId != 0 && ClaimChannelRemainingSeconds > 0;

        // Remaining time on channel (counts down to 0)
        public double ClaimChannelRemainingSeconds { get; private set; }

        // HUD prompt info (computed each frame)
        public bool CanClaimNow { get; private set; }
        public int ClaimCandidateDepositId { get; private set; } // 0 if none
        public int ClaimCandidateTx { get; private set; }
        public int ClaimCandidateTy { get; private set; }

        // Last action HUD line (debug)
        public string LastActionText { get; private set; } = "";
        public double LastActionFlashSeconds { get; private set; }

        public void PostStatus(string text, double seconds = 1.5)
        {
            LastActionText = text ?? "";
            LastActionFlashSeconds = seconds;
        }

        private int _seed;
        public int Seed => _seed;

        private Random _scanRng = null!;

        // claim internal
        private int _claimTargetDepositId; // 0 means none
        private int _claimStartTx;
        private int _claimStartTy;

        // extraction internal (NEW)
        private int _extractTargetDepositId; // 0 means none
        private double _extractKgCarry;      // fractional kg carry to avoid loss

        private struct MovementStep
        {
            public double Vx;
            public double Vy;
            public bool MovedThisFrame;

            public int PlayerTx;
            public int PlayerTy;
        }

        public void InitializeNewGame(int seed)
        {
            _seed = seed;
            _scanRng = new Random(seed ^ 0x5A17C3D1);

            Chunks = new ChunkManager(seed, WORLD_W_TILES, WORLD_H_TILES, cacheMaxChunks: 256);
            Fog = new FogOfWar(WORLD_W_TILES, WORLD_H_TILES);
            Deposits = new DepositManager(seed);

            Npcs = new NpcMinerManager(seed);
            Npcs.InitializeMvpNpcSet(NpcMinerCount);

            BackpackTier = 1;
            Backpack = new Backpack { CapacityKg = UpgradeCatalog.BackpackCapacityKgForTier(BackpackTier) };
            TownStorage = new TownStorage();

            // MVP: define "town" as the start location (later: real town biome/parcel)
            TownCenterTx = WORLD_W_TILES / 2;
            TownCenterTy = WORLD_H_TILES / 2;

            // Start at town center
            Player.PositionX = TownCenterTx;
            Player.PositionY = TownCenterTy;

            // Ensure initial chunks loaded
            Chunks.EnsureActiveRadius(Player.PositionX, Player.PositionY, ActiveChunkRadius);

            // Populate deposits for already-loaded chunks (first frame)
            PopulateDepositsForActiveChunks();

            // ===== TESTING: guaranteed nearby deposit so scan + claim are always testable =====
            {
                int pTx = (int)Math.Floor(Player.PositionX);
                int pTy = (int)Math.Floor(Player.PositionY);

                // Place 2 tiles east so Tier-1 radius=4 will definitely hit it
                int dTx = Math.Min(pTx + 2, WORLD_W_TILES - 2);
                int dTy = pTy;

                var cc = ChunkManager.TileToChunk(dTx, dTy);
                var ch = Chunks.GetOrLoadChunk(cc.Cx, cc.Cy);

                const int debugId = 7777777;

                var debugDeposit = new Deposit
                {
                    DepositId = debugId,
                    OreTypeId = "iron",
                    CenterTx = dTx,
                    CenterTy = dTy,
                    DepthMeters = 80,
                    SizeTier = 8,
                    RemainingUnits = 224,
                    DiscoveredByPlayer = false
                };

                Deposits.AddOrReplaceDepositToChunk(ch, debugDeposit);
            }

            LastActionText = "NEW GAME";
            LastActionFlashSeconds = 1.5;

            // reset claim
            _claimTargetDepositId = 0;
            ClaimChannelRemainingSeconds = 0;
            // reset extraction
            _extractTargetDepositId = 0;
            _extractKgCarry = 0.0;
            ExtractKgRemainder = 0.0;

            Credits = 100; // MVP start
        }

        public void Update(double dtSeconds, InputSnapshot input)
        {
            // 0) Global time
            Clock.Advance(dtSeconds);

            // 1) Streaming & deposits (must happen early so reads are valid)
            StepChunkStreamingAndDeposits();

            // 2) Movement (authoritative)
            MovementStep mv = StepMovement(dtSeconds, input);

            // 3) Town zone (must be computed BEFORE any town-gated actions)
            StepTownZone(mv.PlayerTx, mv.PlayerTy);

            // 4) Town actions (upgrade / deposit / sell). Uses IsInTownZone.
            StepTownActions(input);

            // ===== Vault Authentication gating =====
            if (!HasWon)
            {
                if (!VaultAuthInProgress)
                {
                    // Start authentication once, when all artifacts are present in the Vault
                    if (HasAllArtifactsInVault())
                    {
                        VaultAuthInProgress = true;
                        VaultAuthRemainingSeconds = VaultAuthTotalSeconds;
                        PostStatus("VAULT AUTH STARTED", 2.0);
                    }
                }
                else
                {
                    // Tick authentication
                    VaultAuthRemainingSeconds -= dtSeconds;
                    if (VaultAuthRemainingSeconds <= 0)
                    {
                        VaultAuthRemainingSeconds = 0;
                        VaultAuthInProgress = false;

                        HasWon = true;
                        PostStatus("DIRECTIVE COMPLETE", 3.0);
                        VictoryAchieved?.Invoke();
                    }
                }
            }
            // ============================================


            // 5) Fog (depends on position + clock)
            StepFog(mv.PlayerTx, mv.PlayerTy);

            // 6) Candidate prompts (depends on updated deposits + position)
            StepCandidates(mv.PlayerTx, mv.PlayerTy);

            // 7) Scan / Claim / Extract inputs
            StepScan(input, mv.PlayerTx, mv.PlayerTy);
            StepClaimInput(input, mv.PlayerTx, mv.PlayerTy);
            StepExtractInput(input);

            // 8) Claim / Extract ticks (continuous behaviors)
            StepClaimTick(dtSeconds, mv.PlayerTx, mv.PlayerTy, mv.MovedThisFrame);
            StepExtractTick(dtSeconds, mv.PlayerTx, mv.PlayerTy, mv.MovedThisFrame);

            // 8.5) NPC miners (headless competition)
            StepNpcMiners(dtSeconds);

            // 9) Timers
            StepTimers(dtSeconds);

        }

        private void StepChunkStreamingAndDeposits()
        {
            // Ensure chunk streaming around player/camera
            Chunks.EnsureActiveRadius(Player.PositionX, Player.PositionY, ActiveChunkRadius);
            PopulateDepositsForActiveChunks();
        }

        private MovementStep StepMovement(double dtSeconds, InputSnapshot input)
        {
            // ----- Movement -----
            double vx = 0, vy = 0;
            if (input.MoveUp) vy -= 1;
            if (input.MoveDown) vy += 1;
            if (input.MoveLeft) vx -= 1;
            if (input.MoveRight) vx += 1;

            double len = Math.Sqrt(vx * vx + vy * vy);
            if (len > 1e-9) { vx /= len; vy /= len; }

            double nextX = Player.PositionX + vx * Player.MoveSpeedTilesPerSec * dtSeconds;
            double nextY = Player.PositionY + vy * Player.MoveSpeedTilesPerSec * dtSeconds;

            nextX = Math.Clamp(nextX, 0, WORLD_W_TILES - 1);
            nextY = Math.Clamp(nextY, 0, WORLD_H_TILES - 1);

            Player.PositionX = nextX;
            Player.PositionY = nextY;

            int playerTx = (int)Math.Floor(Player.PositionX);
            int playerTy = (int)Math.Floor(Player.PositionY);

            bool movedThisFrame = (Math.Abs(vx) > 1e-9) || (Math.Abs(vy) > 1e-9);

            return new MovementStep
            {
                Vx = vx,
                Vy = vy,
                MovedThisFrame = movedThisFrame,
                PlayerTx = playerTx,
                PlayerTy = playerTy
            };
        }

        private void StepTownZone(int playerTx, int playerTy)
        {
            int dxT = playerTx - TownCenterTx;
            int dyT = playerTy - TownCenterTy;
            IsInTownZone = (dxT * dxT + dyT * dyT) <= TownRadiusTiles * TownRadiusTiles;
        }

        private void StepTownActions(InputSnapshot input)
        {
            // ----- Upgrade hotkeys (town-only, costs Credits) -----
            if (IsInTownZone)
            {
                TryPurchaseUpgrades(input);
            }
            else
            {
                if ((input.DevSetDetectorTier is >= 1 and <= 5) ||
                    (input.DevSetExtractorTier is >= 1 and <= 5) ||
                    (input.DevSetBackpackTier is >= 1 and <= 5))
                {
                    LastActionText = "UPGRADE BLOCKED (not in town)";
                    LastActionFlashSeconds = 1.5;
                }
            }

            // ----- Deposit backpack into town storage -----
            if (input.DepositPressed)
            {
                if (!IsInTownZone)
                {
                    LastActionText = "DEPOSIT FAILED (not in town)";
                    LastActionFlashSeconds = 1.5;
                }
                else
                {
                    int movedStacks = Backpack.TransferAllTo(TownStorage);

                    LastActionText = movedStacks > 0 ? "DEPOSIT OK" : "DEPOSIT (nothing)";
                    LastActionFlashSeconds = 1.5;
                }
            }

            // ----- Sell town storage ore for credits -----
            if (input.SellPressed)
            {
                if (!IsInTownZone)
                {
                    LastActionText = "SELL FAILED (not in town)";
                    LastActionFlashSeconds = 1.5;
                }
                else
                {
                    var result = TownStorage.ComputeSaleValueAndClear();
                    int totalCredits = result.creditsGained;
                    int stacks = result.stacksSold;

                    if (totalCredits > 0)
                    {
                        Credits += totalCredits;
                        LastActionText = $"SOLD {stacks} STACKS  +{totalCredits} cr";
                    }
                    else
                    {
                        LastActionText = "SELL (nothing)";
                    }

                    LastActionFlashSeconds = 1.5;
                }
            }
        }

        private void StepFog(int playerTx, int playerTy)
        {
            Fog.ClearVisibleNow();
            int vision = Clock.IsNight ? 6 : 9; // MVP: no equipped light yet
            Fog.RevealCircle(playerTx, playerTy, vision);
        }

        private void StepCandidates(int playerTx, int playerTy)
        {
            ComputeClaimCandidate(playerTx, playerTy);
            ComputeExtractCandidate(playerTx, playerTy);
        }

        private void StepScan(InputSnapshot input, int playerTx, int playerTy)
        {
            if (!input.ScanPressed)
                return;

            bool scanExecuted = false;

            if (ScanCooldownRemainingSeconds <= 0.0)
            {
                LastScanCenterTx = playerTx;
                LastScanCenterTy = playerTy;
                LastScanRadiusTiles = Player.DetectorRadiusTiles;
                LastScanFlashSeconds = 0.35;

                LastScanResults = Deposits.Scan(
                    Chunks,
                    scanCenterTx: playerTx,
                    scanCenterTy: playerTy,
                    radiusTiles: Player.DetectorRadiusTiles,
                    maxDepthMeters: Player.DetectorMaxDepthMeters,
                    sizeNoiseTiers: Player.DetectorSizeNoiseTiers,
                    rng: _scanRng);

                // Sort scan results by priority (highest first)
                LastScanResults.Sort((a, b) =>
                {
                    double pa = a.ComputePriorityScore();
                    double pb = b.ComputePriorityScore();
                    return pb.CompareTo(pa);
                });

                foreach (var sr in LastScanResults)
                    MarkDepositDiscoveredById(sr.DepositId);

                ScanCooldownRemainingSeconds = Player.DetectorCooldownSeconds;
                scanExecuted = true;

                LastActionText = $"SCAN OK  hits={LastScanResults.Count}";
                LastActionFlashSeconds = 1.5;
            }
            else
            {
                LastActionText = $"SCAN BLOCKED  cd={ScanCooldownRemainingSeconds:0.0}s";
                LastActionFlashSeconds = 1.5;
            }

            if (scanExecuted) ScanExecuted?.Invoke();
            else ScanDud?.Invoke();
        }

        private void StepClaimInput(InputSnapshot input, int playerTx, int playerTy)
        {
            if (!input.ClaimPressed)
                return;

            if (ClaimInProgress)
            {
                CancelClaim("CLAIM CANCELED");
                ClaimFailed?.Invoke();
                return;
            }

            if (CanClaimNow && ClaimCandidateDepositId != 0)
            {
                StartClaim(playerTx, playerTy, ClaimCandidateDepositId);
                LastActionText = "CLAIM START";
                LastActionFlashSeconds = 1.5;
            }
            else
            {
                LastActionText = "CLAIM FAILED (not in range)";
                LastActionFlashSeconds = 1.5;
                ClaimFailed?.Invoke();
            }
        }

        private void StepExtractInput(InputSnapshot input)
        {
            if (!input.ExtractPressed)
                return;

            if (ExtractInProgress)
            {
                StopExtraction("EXTRACT STOP");
                return;
            }

            if (CanExtractNow && ExtractCandidateDepositId != 0)
            {
                StartExtraction(ExtractCandidateDepositId);
                LastActionText = "EXTRACT START";
                LastActionFlashSeconds = 1.5;
            }
            else
            {
                LastActionText = "EXTRACT FAILED (not eligible)";
                LastActionFlashSeconds = 1.5;
            }
        }

        private void StepClaimTick(double dtSeconds, int playerTx, int playerTy, bool movedThisFrame)
        {
            if (!ClaimInProgress)
                return;

            if (movedThisFrame)
            {
                CancelClaim("CLAIM INTERRUPTED (moved)");
                ClaimFailed?.Invoke();
                return;
            }

            if (!IsStillInClaimRange(playerTx, playerTy, _claimTargetDepositId))
            {
                CancelClaim("CLAIM INTERRUPTED (out of range)");
                ClaimFailed?.Invoke();
                return;
            }

            ClaimChannelRemainingSeconds -= dtSeconds;
            if (ClaimChannelRemainingSeconds <= 0)
            {
                ClaimChannelRemainingSeconds = 0;

                bool ok = CompleteClaim(_claimTargetDepositId);
                _claimTargetDepositId = 0;

                if (ok)
                {
                    LastActionText = "CLAIM OK";
                    LastActionFlashSeconds = 1.5;
                    ClaimSucceeded?.Invoke();
                }
                else
                {
                    LastActionText = "CLAIM FAILED (lost eligibility)";
                    LastActionFlashSeconds = 1.5;
                    ClaimFailed?.Invoke();
                }
            }
        }

        private void StepExtractTick(double dtSeconds, int playerTx, int playerTy, bool movedThisFrame)
        {
            if (!ExtractInProgress)
                return;

            if (movedThisFrame)
            {
                StopExtraction("EXTRACT INTERRUPTED (moved)");
                return;
            }

            var d = Deposits.TryGetDepositById(_extractTargetDepositId);
            if (d == null)
            {
                StopExtraction("EXTRACT INTERRUPTED (missing)");
                return;
            }

            if (!IsStillEligibleForExtraction(playerTx, playerTy, d))
            {
                StopExtraction("EXTRACT INTERRUPTED (eligibility)");
                return;
            }

            if (Backpack.IsFull)
            {
                StopExtraction("EXTRACT STOP (backpack full)");
                return;
            }

            TickExtraction(dtSeconds, d);
        }

        private void StepNpcMiners(double dtSeconds)
        {
            if (Npcs == null) return;
            if (Deposits == null) return;

            Npcs.Tick(dtSeconds, Deposits);
        }

        private void StepTimers(double dtSeconds)
        {
            if (LastScanFlashSeconds > 0)
            {
                LastScanFlashSeconds -= dtSeconds;
                if (LastScanFlashSeconds < 0) LastScanFlashSeconds = 0;
            }

            if (ScanCooldownRemainingSeconds > 0)
            {
                ScanCooldownRemainingSeconds -= dtSeconds;
                if (ScanCooldownRemainingSeconds < 0) ScanCooldownRemainingSeconds = 0;
            }

            if (LastActionFlashSeconds > 0)
            {
                LastActionFlashSeconds -= dtSeconds;
                if (LastActionFlashSeconds < 0) LastActionFlashSeconds = 0;
            }
        }


        private void PopulateDepositsForActiveChunks()
        {
            int centerTx = (int)Math.Floor(Player.PositionX);
            int centerTy = (int)Math.Floor(Player.PositionY);
            var center = ChunkManager.TileToChunk(centerTx, centerTy);

            for (int dy = -ActiveChunkRadius; dy <= ActiveChunkRadius; dy++)
                for (int dx = -ActiveChunkRadius; dx <= ActiveChunkRadius; dx++)
                {
                    int cx = center.Cx + dx;
                    int cy = center.Cy + dy;

                    Chunk ch;
                    try { ch = Chunks.GetOrLoadChunk(cx, cy); }
                    catch { continue; }

                    // Populate at most once per chunk (requires Chunk.DepositsPopulated in Chunk.cs)
                    if (!ch.DepositsPopulated)
                    {
                        Deposits.PopulateChunkDeposits(ch, TownCenterTx, TownCenterTy);
                        ch.DepositsPopulated = true;
                    }
                }
        }

        private void MarkDepositDiscoveredById(int depositId)
        {
            var d = Deposits.TryGetDepositById(depositId);
            if (d != null) d.DiscoveredByPlayer = true;
        }

        // ===== Claim candidate + channel helpers (NEW) =====

        private const int ClaimRangeTiles = 2;

        private void ComputeClaimCandidate(int playerTx, int playerTy)
        {
            CanClaimNow = false;
            ClaimCandidateDepositId = 0;

            int bestDist2 = int.MaxValue;
            Deposit best = null;

            foreach (var ch in Chunks.GetLoadedChunks())
                foreach (var d in ch.Deposits)
                {
                    if (!d.DiscoveredByPlayer) continue;
                    if (d.RemainingUnits <= 0) continue;
                    if (d.ClaimedByPlayer) continue;
                    if (d.ClaimedByNpcId.HasValue) continue;

                    int dx = d.CenterTx - playerTx;
                    int dy = d.CenterTy - playerTy;
                    int dist2 = dx * dx + dy * dy;

                    if (dist2 <= ClaimRangeTiles * ClaimRangeTiles && dist2 < bestDist2)
                    {
                        bestDist2 = dist2;
                        best = d;
                    }
                }

            if (best != null)
            {
                CanClaimNow = true;
                ClaimCandidateDepositId = best.DepositId;
                ClaimCandidateTx = best.CenterTx;
                ClaimCandidateTy = best.CenterTy;
            }
        }

        private void StartClaim(int playerTx, int playerTy, int depositId)
        {
            _claimTargetDepositId = depositId;
            ClaimChannelRemainingSeconds = ClaimChannelTotalSeconds;
            _claimStartTx = playerTx;
            _claimStartTy = playerTy;
        }

        private void CancelClaim(string reason)
        {
            _claimTargetDepositId = 0;
            ClaimChannelRemainingSeconds = 0;
            LastActionText = reason;
            LastActionFlashSeconds = 1.5;
        }

        private bool IsStillInClaimRange(int playerTx, int playerTy, int depositId)
        {
            var d = Deposits.TryGetDepositById(depositId);
            if (d == null) return false;

            // still eligible?
            if (!d.DiscoveredByPlayer) return false;
            if (d.RemainingUnits <= 0) return false;
            if (d.ClaimedByPlayer) return false;
            if (d.ClaimedByNpcId.HasValue) return false;

            int dx = d.CenterTx - playerTx;
            int dy = d.CenterTy - playerTy;
            int dist2 = dx * dx + dy * dy;
            return dist2 <= ClaimRangeTiles * ClaimRangeTiles;
        }

        private bool CompleteClaim(int depositId)
        {
            var d = Deposits.TryGetDepositById(depositId);
            if (d == null) return false;

            // re-check eligibility at completion time
            if (!d.DiscoveredByPlayer) return false;
            if (d.RemainingUnits <= 0) return false;
            if (d.ClaimedByPlayer) return false;
            if (d.ClaimedByNpcId.HasValue) return false;

            d.ClaimedByPlayer = true;
            return true;
        }

        // ===== Extraction helpers (NEW) =====

        private void ComputeExtractCandidate(int playerTx, int playerTy)
        {
            CanExtractNow = false;
            ExtractCandidateDepositId = 0;

            int bestDist2 = int.MaxValue;
            Deposit best = null;

            foreach (var ch in Chunks.GetLoadedChunks())
                foreach (var d in ch.Deposits)
                {
                    if (!d.DiscoveredByPlayer) continue;
                    if (d.RemainingUnits <= 0) continue;

                    // Must be player-claimed for MVP extraction
                    if (!d.ClaimedByPlayer) continue;

                    // Must be in extractor depth capability
                    if (d.DepthMeters > Player.ExtractorMaxDepthMeters) continue;

                    int dx = d.CenterTx - playerTx;
                    int dy = d.CenterTy - playerTy;
                    int dist2 = dx * dx + dy * dy;

                    int r = Player.ExtractorRangeTiles;
                    if (dist2 <= r * r && dist2 < bestDist2)
                    {
                        bestDist2 = dist2;
                        best = d;
                    }
                }

            if (best != null)
            {
                CanExtractNow = true;
                ExtractCandidateDepositId = best.DepositId;
                ExtractCandidateTx = best.CenterTx;
                ExtractCandidateTy = best.CenterTy;
            }
        }

        private bool IsStillEligibleForExtraction(int playerTx, int playerTy, Deposit d)
        {
            if (!d.DiscoveredByPlayer) return false;
            if (d.RemainingUnits <= 0) return false;
            if (!d.ClaimedByPlayer) return false;
            if (d.ClaimedByNpcId.HasValue) return false; // future-proof

            if (d.DepthMeters > Player.ExtractorMaxDepthMeters) return false;

            int dx = d.CenterTx - playerTx;
            int dy = d.CenterTy - playerTy;
            int dist2 = dx * dx + dy * dy;

            int r = Player.ExtractorRangeTiles;
            return dist2 <= r * r;
        }

        private void StartExtraction(int depositId)
        {
            _extractTargetDepositId = depositId;
            _extractKgCarry = 0.0;
            ExtractKgRemainder = 0.0;
        }

        private void StopExtraction(string reason)
        {
            _extractTargetDepositId = 0;
            _extractKgCarry = 0.0;
            ExtractKgRemainder = 0.0;

            LastActionText = reason;
            LastActionFlashSeconds = 1.5;
        }

        private void TickExtraction(double dtSeconds, Deposit d)
        {
            // ===== Artifact extraction (quest items) =====
            if (d.IsArtifact)
            {
                // MVP: allow extraction if in range and player-claimed (already enforced by caller)
                // Add to backpack as a unique artifact ID, not as ore.

                string aid = d.ArtifactId ?? "";
                bool added = Backpack.AddArtifact(aid);

                // Deplete deposit immediately (artifact is one-time)
                d.RemainingUnits = 0;

                StopExtraction(added
                    ? $"ARTIFACT SECURED: {aid}"
                    : $"ARTIFACT ALREADY HAVE: {aid}");

                return;
            }
            // ===========================================

            // MVP: no MiningSkill yet. When you add skills, apply bonus here.
            double baseRateKgPerSec = Player.ExtractorRateKgPerSec;

            // Difficulty from catalog (later: from ores.json)
            double diff = OreCatalog.ExtractionDifficulty(d.OreTypeId);
            if (diff < 1e-6) diff = 1.0;

            double rateKgPerSec = baseRateKgPerSec / diff;
            if (rateKgPerSec < 1e-6) rateKgPerSec = 1e-6;

            double kgThisTick = rateKgPerSec * dtSeconds;

            // Convert kg -> units with carry to avoid fractional loss
            double unitKg = OreCatalog.UnitMassKg(d.OreTypeId);
            if (unitKg < 1e-6) unitKg = 1.0;

            _extractKgCarry += kgThisTick;

            int unitsPotential = (int)System.Math.Floor(_extractKgCarry / unitKg);
            if (unitsPotential <= 0)
            {
                ExtractKgRemainder = _extractKgCarry;
                return;
            }

            // Bound by deposit remaining
            int unitsByDeposit = System.Math.Min(unitsPotential, d.RemainingUnits);
            if (unitsByDeposit <= 0)
            {
                StopExtraction("EXTRACT STOP (depleted)");
                return;
            }

            // Bound by backpack capacity
            int unitsAdded = Backpack.AddOreUnitsClamped(d.OreTypeId, unitsByDeposit);
            if (unitsAdded <= 0)
            {
                StopExtraction("EXTRACT STOP (backpack full)");
                return;
            }

            // Apply effects
            d.RemainingUnits -= unitsAdded;

            // Spend kg carry for the units we actually added
            _extractKgCarry -= unitsAdded * unitKg;
            if (_extractKgCarry < 0) _extractKgCarry = 0;

            ExtractKgRemainder = _extractKgCarry;

            // Auto-stop if deposit depleted
            if (d.RemainingUnits <= 0)
            {
                d.RemainingUnits = 0;
                StopExtraction("EXTRACT STOP (depleted)");
            }
        }

        private void TryPurchaseUpgrades(InputSnapshot input)
        {
            // Detector upgrade request
            if (input.DevSetDetectorTier is >= 1 and <= 5)
            {
                int desired = input.DevSetDetectorTier;
                if (desired > Player.DetectorTier)
                {
                    int cost = MineIt.Inventory.UpgradeCatalog.DetectorPriceForTier(desired);
                    if (Credits >= cost)
                    {
                        Credits -= cost;
                        Player.DetectorTier = desired;
                        LastActionText = $"BOUGHT Detector T{desired}  -{cost} cr";
                    }
                    else
                    {
                        LastActionText = $"NEED {cost} cr for Detector T{desired}";
                    }
                    LastActionFlashSeconds = 1.5;
                }
            }

            // Extractor upgrade request
            if (input.DevSetExtractorTier is >= 1 and <= 5)
            {
                int desired = input.DevSetExtractorTier;
                if (desired > Player.ExtractorTier)
                {
                    int cost = MineIt.Inventory.UpgradeCatalog.ExtractorPriceForTier(desired);
                    if (Credits >= cost)
                    {
                        Credits -= cost;
                        Player.ExtractorTier = desired;
                        LastActionText = $"BOUGHT Extractor T{desired}  -{cost} cr";
                    }
                    else
                    {
                        LastActionText = $"NEED {cost} cr for Extractor T{desired}";
                    }
                    LastActionFlashSeconds = 1.5;
                }
            }

            // Backpack upgrade request
            if (input.DevSetBackpackTier is >= 1 and <= 5)
            {
                int desired = input.DevSetBackpackTier;
                if (desired > BackpackTier)
                {
                    int cost = MineIt.Inventory.UpgradeCatalog.BackpackPriceForTier(desired);
                    if (Credits >= cost)
                    {
                        Credits -= cost;
                        BackpackTier = desired;

                        double cap = MineIt.Inventory.UpgradeCatalog.BackpackCapacityKgForTier(desired);
                        Backpack.CapacityKg = System.Math.Max(cap, Backpack.CurrentKg); // never invalidate current weight

                        LastActionText = $"BOUGHT Backpack T{desired} ({Backpack.CapacityKg:0}kg)  -{cost} cr";
                    }
                    else
                    {
                        LastActionText = $"NEED {cost} cr for Backpack T{desired}";
                    }
                    LastActionFlashSeconds = 1.5;
                }
            }
        }

        private static readonly string[] RequiredArtifacts =
{
    "stellar_shard",
    "ancient_lattice",
    "void_compass",
    "quantum_fossil",
    "machine_relic",
    "echo_prism"
};

        private bool HasAllArtifactsInVault()
        {
            if (TownStorage == null) return false;

            for (int i = 0; i < RequiredArtifacts.Length; i++)
            {
                if (!TownStorage.HasArtifact(RequiredArtifacts[i]))
                    return false;
            }
            return true;
        }

        public void LoadFromSave(Save.SaveGameData data)
        {
            if (data == null) return;

            // Re-init deterministic session from seed
            InitializeNewGame(data.Seed);

            HasWon = data.HasWon;
            VaultAuthInProgress = data.VaultAuthInProgress;
            VaultAuthRemainingSeconds = data.VaultAuthRemainingSeconds;

            // Clock
            // We only have Advance() currently; set via repeated advance is dumb.
            // So: set using reflection-free direct assignment by adding a setter-like approach.
            // Minimal: advance to target.
            double target = data.TotalRealSeconds;
            double cur = Clock.TotalRealSeconds;
            if (target > cur)
                Clock.Advance(target - cur);

            // Player + upgrades
            Player.PositionX = data.Player.PositionX;
            Player.PositionY = data.Player.PositionY;

            Player.DetectorTier = data.Player.DetectorTier;
            Player.ExtractorTier = data.Player.ExtractorTier;

            BackpackTier = data.Player.BackpackTier;
            Credits = data.Player.Credits;

            // Ensure backpack capacity matches tier (never invalidates current load)
            double cap = MineIt.Inventory.UpgradeCatalog.BackpackCapacityKgForTier(BackpackTier);
            Backpack.CapacityKg = cap;

            // Inventory
            Backpack.LoadOreUnits(data.BackpackOre);
            TownStorage.LoadOreUnits(data.TownOre);

            Backpack.LoadArtifacts(data.BackpackArtifacts);
            TownStorage.LoadArtifacts(data.TownArtifacts);

            // Fog
            if (!string.IsNullOrEmpty(data.FogDiscoveredBitsBase64))
            {
                byte[] bytes = Convert.FromBase64String(data.FogDiscoveredBitsBase64);
                uint[] bits = new uint[(bytes.Length + 3) / 4];
                Buffer.BlockCopy(bytes, 0, bits, 0, Math.Min(bytes.Length, bits.Length * 4));
                Fog.OverwriteDiscoveredBits(bits);
            }

            // Deposits: apply mutable deltas (chunks/deposits exist as they are loaded)
            // Ensure active chunks are loaded so at least local deposits exist
            Chunks.EnsureActiveRadius(Player.PositionX, Player.PositionY, ActiveChunkRadius);
            PopulateDepositsForActiveChunks();

            foreach (var sd in data.Deposits)
            {
                var d = Deposits.TryGetDepositById(sd.DepositId);
                if (d == null) continue;

                d.RemainingUnits = sd.RemainingUnits;

                // Artifacts
                d.IsArtifact = sd.IsArtifact;
                d.ArtifactId = sd.ArtifactId ?? "";

                d.ClaimedByPlayer = sd.ClaimedByPlayer;
                d.ClaimedByNpcId = (sd.ClaimedByNpcId >= 0) ? sd.ClaimedByNpcId : (int?)null;
                d.DiscoveredByPlayer = sd.DiscoveredByPlayer;
            }

            // NPC miners
            if (data.NpcMiners != null && data.NpcMiners.Count > 0)
            {
                Npcs.LoadFromSave(data.NpcMiners);

                // Re-assert deposit ownership consistency for NPC targets (best-effort):
                // If an NPC has a target deposit, ensure the deposit's ClaimedByNpcId is set.
                for (int i = 0; i < Npcs.Npcs.Count; i++)
                {
                    var npc = Npcs.Npcs[i];
                    if (npc.TargetDepositId == 0) continue;

                    var d = Deposits.TryGetDepositById(npc.TargetDepositId);
                    if (d != null && !d.ClaimedByPlayer)
                    {
                        if (!d.ClaimedByNpcId.HasValue)
                            d.ClaimedByNpcId = npc.NpcId;
                    }
                }
            }
            else
            {
                // No NPC data in old saves -> initialize default NPCs
                Npcs.InitializeMvpNpcSet(NpcMinerCount);
            }

            LastActionText = "LOAD OK";
            LastActionFlashSeconds = 1.5;
        }





    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\World\Chunk.cs =====
using System.Collections.Generic;
using MineIt.Mining;

namespace MineIt.World
{
    public sealed class Chunk
    {
        public const int CHUNK_SIZE_TILES = 32;

        public ChunkCoord Coord { get; }

        private readonly byte[] _tiles; // size = 32*32

        private readonly List<Deposit> _deposits = new List<Deposit>();
        public System.Collections.Generic.IReadOnlyList<Deposit> Deposits => _deposits;

        internal bool DepositsPopulated { get; set; }

        // Core-only accessors (DepositManager / generator use these)
        internal List<Deposit> DepositsMutable => _deposits;

        public Chunk(ChunkCoord coord)
        {
            Coord = coord;
            _tiles = new byte[CHUNK_SIZE_TILES * CHUNK_SIZE_TILES];
        }

        public byte GetLocalTile(int lx, int ly)
        {
            if ((uint)lx >= CHUNK_SIZE_TILES || (uint)ly >= CHUNK_SIZE_TILES) return 1;
            return _tiles[ly * CHUNK_SIZE_TILES + lx];
        }

        internal void SetLocalTile(int lx, int ly, byte v)
        {
            if ((uint)lx >= CHUNK_SIZE_TILES || (uint)ly >= CHUNK_SIZE_TILES) return;
            _tiles[ly * CHUNK_SIZE_TILES + lx] = v;
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\World\ChunkCoord.cs =====
using System;

namespace MineIt.World
{
    public readonly struct ChunkCoord : IEquatable<ChunkCoord>
    {
        public readonly int Cx;
        public readonly int Cy;

        public ChunkCoord(int cx, int cy) { Cx = cx; Cy = cy; }

        public bool Equals(ChunkCoord other) => Cx == other.Cx && Cy == other.Cy;
        public override bool Equals(object obj) => obj is ChunkCoord other && Equals(other);
        public override int GetHashCode() => HashCode.Combine(Cx, Cy);
        public override string ToString() => $"({Cx},{Cy})";
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\World\ChunkManager.cs =====
using System;
using System.Collections.Generic;

namespace MineIt.World
{
    public sealed class ChunkManager
    {
        public const int CHUNK_SIZE_TILES = Chunk.CHUNK_SIZE_TILES;

        private readonly int _worldWidthTiles;
        private readonly int _worldHeightTiles;

        private readonly WorldGenerator _gen;
        private readonly int _cacheMaxChunks;

        // Cache + LRU
        private readonly Dictionary<ChunkCoord, Chunk> _chunks = new();
        private readonly LinkedList<ChunkCoord> _lru = new(); // most-recent at end
        private readonly Dictionary<ChunkCoord, LinkedListNode<ChunkCoord>> _lruNodes = new();

        public int WorldWidthTiles => _worldWidthTiles;
        public int WorldHeightTiles => _worldHeightTiles;


        public ChunkManager(int seed, int worldWidthTiles, int worldHeightTiles, int cacheMaxChunks = 256)
        {
            _gen = new WorldGenerator(seed);
            _worldWidthTiles = worldWidthTiles;
            _worldHeightTiles = worldHeightTiles;
            _cacheMaxChunks = Math.Max(16, cacheMaxChunks);
        }

        public System.Collections.Generic.IEnumerable<Chunk> GetLoadedChunks()
        {
            // Expose loaded chunk instances for renderers (Unity-side).
            // Safe: caller must not mutate chunk tiles directly.
            return _chunks.Values;
        }

        public static ChunkCoord TileToChunk(int tx, int ty)
            => new ChunkCoord(FloorDiv(tx, CHUNK_SIZE_TILES), FloorDiv(ty, CHUNK_SIZE_TILES));

        public static (int lx, int ly) TileToLocal(int tx, int ty)
        {
            int lx = Mod(tx, CHUNK_SIZE_TILES);
            int ly = Mod(ty, CHUNK_SIZE_TILES);
            return (lx, ly);
        }

        public Chunk GetOrLoadChunk(int cx, int cy)
        {
            // World bounds clamp (finite world MVP).
            int maxCx = (_worldWidthTiles - 1) / CHUNK_SIZE_TILES;
            int maxCy = (_worldHeightTiles - 1) / CHUNK_SIZE_TILES;
            if (cx < 0 || cy < 0 || cx > maxCx || cy > maxCy)
                throw new ArgumentOutOfRangeException($"Chunk {cx},{cy} outside world.");

            var cc = new ChunkCoord(cx, cy);
            if (_chunks.TryGetValue(cc, out var existing))
            {
                Touch(cc);
                return existing;
            }

            var chunk = new Chunk(cc);
            _gen.FillChunkTiles(chunk);

            _chunks[cc] = chunk;
            AddToLru(cc);

            EvictIfNeeded();
            return chunk;
        }

        public void EnsureActiveRadius(double camXTile, double camYTile, int radiusChunks)
        {
            int centerTx = (int)Math.Floor(camXTile);
            int centerTy = (int)Math.Floor(camYTile);
            var center = TileToChunk(centerTx, centerTy);

            for (int dy = -radiusChunks; dy <= radiusChunks; dy++)
                for (int dx = -radiusChunks; dx <= radiusChunks; dx++)
                {
                    int cx = center.Cx + dx;
                    int cy = center.Cy + dy;

                    // Skip outside finite world bounds.
                    int maxCx = (_worldWidthTiles - 1) / CHUNK_SIZE_TILES;
                    int maxCy = (_worldHeightTiles - 1) / CHUNK_SIZE_TILES;
                    if (cx < 0 || cy < 0 || cx > maxCx || cy > maxCy) continue;

                    _ = GetOrLoadChunk(cx, cy);
                }
        }

        public byte GetTile(int tx, int ty)
        {
            if ((uint)tx >= (uint)_worldWidthTiles || (uint)ty >= (uint)_worldHeightTiles) return 1;

            var cc = TileToChunk(tx, ty);
            var chunk = GetOrLoadChunk(cc.Cx, cc.Cy);
            var (lx, ly) = TileToLocal(tx, ty);
            return chunk.GetLocalTile(lx, ly);
        }

        private void EvictIfNeeded()
        {
            while (_chunks.Count > _cacheMaxChunks)
            {
                var oldest = _lru.First!;
                var cc = oldest.Value;

                _lru.RemoveFirst();
                _lruNodes.Remove(cc);
                _chunks.Remove(cc);
            }
        }

        private void Touch(ChunkCoord cc)
        {
            if (_lruNodes.TryGetValue(cc, out var node))
            {
                _lru.Remove(node);
                _lruNodes.Remove(cc);
            }
            AddToLru(cc);
        }

        private void AddToLru(ChunkCoord cc)
        {
            var node = _lru.AddLast(cc);
            _lruNodes[cc] = node;
        }

        private static int FloorDiv(int a, int b)
        {
            // floor division for negative values too (safe future-proofing)
            int q = a / b;
            int r = a % b;
            if (r != 0 && ((r > 0) != (b > 0))) q--;
            return q;
        }

        private static int Mod(int a, int b)
        {
            int m = a % b;
            if (m < 0) m += Math.Abs(b);
            return m;
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\World\TileMap.cs =====
using System;

namespace MineIt.World
{
    public sealed class TileMap
    {
        public int Width { get; }
        public int Height { get; }

        // 0 = grass, 1 = rock (for now)
        private readonly byte[] _tiles;

        public TileMap(int width, int height)
        {
            Width = width;
            Height = height;
            _tiles = new byte[width * height];
        }

        public byte GetTile(int tx, int ty)
        {
            if ((uint)tx >= (uint)Width || (uint)ty >= (uint)Height) return 1;
            return _tiles[ty * Width + tx];
        }

        public void Generate(int seed)
        {
            // Simple deterministic pattern (placeholder for noise/biomes later).
            var rng = new Random(seed);

            for (int y = 0; y < Height; y++)
                for (int x = 0; x < Width; x++)
                {
                    // Light “rock speckle” pattern.
                    int r = rng.Next(100);
                    _tiles[y * Width + x] = (byte)(r < 12 ? 1 : 0);
                }
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Core\World\WorldGenerator.cs =====
using System;

namespace MineIt.World
{
    public sealed class WorldGenerator
    {
        private readonly int _seed;

        public WorldGenerator(int seed) => _seed = seed;

        // Deterministic chunk RNG seed (stable across runs)
        public int ChunkSeed(int cx, int cy)
        {
            unchecked
            {
                int h = 17;
                h = h * 31 + _seed;
                h = h * 31 + cx;
                h = h * 31 + cy;
                // mix
                h ^= (h << 13);
                h ^= (h >> 17);
                h ^= (h << 5);
                return h;
            }
        }

        // 0 = grass, 1 = rock (placeholder visuals)
        public void FillChunkTiles(Chunk chunk)
        {
            var rng = new Random(ChunkSeed(chunk.Coord.Cx, chunk.Coord.Cy));
            for (int ly = 0; ly < Chunk.CHUNK_SIZE_TILES; ly++)
                for (int lx = 0; lx < Chunk.CHUNK_SIZE_TILES; lx++)
                {
                    // Slightly different pattern than before; still deterministic.
                    int r = rng.Next(100);
                    byte tile = (byte)(r < 14 ? 1 : 0);
                    chunk.SetLocalTile(lx, ly, tile);
                }
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\Audio\AudioController.cs =====
using UnityEngine;
using MineItUnity.Game.Audio;

namespace MineItUnity.Game
{
    /// <summary>
    /// Unity presentation-only audio adapter.
    /// Subscribes to core GameSession events and plays AudioClips from a ScriptableObject library.
    /// Easy to swap clips later (Unity Store, etc.) by editing the MineItAudioLibrary asset.
    /// </summary>
    public sealed class AudioController : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;
        public MineItAudioLibrary Library;

        [Header("Sources")]
        [Tooltip("One-shot SFX source (recommended).")]
        public AudioSource SfxSource;

        // Future-proof: you can add a loop source later if you buy a loop hum
        // public AudioSource LoopSource;

        private bool _subscribed;
        private bool _prevExtracting;

        // Tracks which deposits have already been discovered (so we only play discovery once).
        private readonly System.Collections.Generic.HashSet<int> _knownDiscoveredDeposits
            = new System.Collections.Generic.HashSet<int>();


        private void Awake()
        {
            // Optional convenience: auto-create a source if not assigned
            if (SfxSource == null)
            {
                var go = new GameObject("SfxSource");
                go.transform.SetParent(transform, worldPositionStays: false);
                SfxSource = go.AddComponent<AudioSource>();
                SfxSource.playOnAwake = false;
                SfxSource.spatialBlend = 0f; // 2D
            }
        }

        private void OnEnable()
        {
            TrySubscribe();
        }

        private void OnDisable()
        {
            Unsubscribe();
        }

        private void Update()
        {
            // If we weren't able to subscribe yet (script enable order), keep trying.
            if (!_subscribed)
                TrySubscribe();

            if (Controller == null || Controller.Session == null || Library == null || SfxSource == null)
                return;

            // Edge-detect extraction start/stop (core has no events yet; this is adapter-side)
            bool extracting = Controller.Session.ExtractInProgress;

            if (!_prevExtracting && extracting)
                Play(Library.ExtractStart, Library.MasterSfxVolume * Library.ExtractVolume);

            if (_prevExtracting && !extracting)
                Play(Library.ExtractStop, Library.MasterSfxVolume * Library.ExtractVolume);

            _prevExtracting = extracting;
        }

        private void TrySubscribe()
        {
            if (_subscribed) return;
            if (Controller == null || Controller.Session == null) return;

            var s = Controller.Session;

            s.ScanExecuted += OnScanExecuted;
            s.ScanDud += OnScanDud;
            s.ClaimSucceeded += OnClaimSucceeded;
            s.ClaimFailed += OnClaimFailed;

            _prevExtracting = s.ExtractInProgress;
            _subscribed = true;

            // Seed discovered set from currently loaded chunks to avoid false "new discovery" dings.
            _knownDiscoveredDeposits.Clear();
            foreach (var ch in s.Chunks.GetLoadedChunks())
            {
                foreach (var d in ch.Deposits)
                {
                    if (d.DiscoveredByPlayer)
                        _knownDiscoveredDeposits.Add(d.DepositId);
                }
            }

        }

        private void Unsubscribe()
        {
            if (!_subscribed) return;
            if (Controller == null || Controller.Session == null) { _subscribed = false; return; }

            var s = Controller.Session;

            s.ScanExecuted -= OnScanExecuted;
            s.ScanDud -= OnScanDud;
            s.ClaimSucceeded -= OnClaimSucceeded;
            s.ClaimFailed -= OnClaimFailed;

            _subscribed = false;
        }

        private void OnScanExecuted()
        {
            // 1) Scan executed sound
            Play(Library.ScanExecuted, Library.MasterSfxVolume * Library.ScanVolume);

            // 2) Discovery sound (if this scan revealed any NEW deposits)
            if (Controller == null || Controller.Session == null || Library == null)
                return;

            var s = Controller.Session;

            int newDiscoveries = 0;

            // LastScanResults is populated before ScanExecuted fires (per your GameSession flow).
            var results = s.LastScanResults;
            if (results != null)
            {
                for (int i = 0; i < results.Count; i++)
                {
                    int id = results[i].DepositId;

                    // If it wasn't known before, this scan just discovered it (or at least it's the first time we see it)
                    if (_knownDiscoveredDeposits.Add(id))
                        newDiscoveries++;
                }
            }

            // Play once per scan if any new deposits were discovered (avoids spam)
            if (newDiscoveries > 0)
            {
                Play(Library.DepositDiscovered, Library.MasterSfxVolume * Library.DiscoveryVolume);
            }
        }

        private void OnScanDud()
        {
            Play(Library.ScanBlocked, Library.MasterSfxVolume * Library.ScanVolume);
        }

        private void OnClaimSucceeded()
        {
            Play(Library.ClaimSucceeded, Library.MasterSfxVolume * Library.ClaimVolume);
        }

        private void OnClaimFailed()
        {
            Play(Library.ClaimFailed, Library.MasterSfxVolume * Library.ClaimVolume);
        }

        private void Play(AudioClip clip, float volume01)
        {
            if (clip == null || SfxSource == null) return;
            SfxSource.PlayOneShot(clip, Mathf.Clamp01(volume01));
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\Audio\MineItAudioLibrary.cs =====
using UnityEngine;

namespace MineItUnity.Game.Audio
{
    [CreateAssetMenu(fileName = "MineItAudioLibrary", menuName = "MineIt/Audio Library", order = 10)]
    public sealed class MineItAudioLibrary : ScriptableObject
    {
        [Header("Scan")]
        public AudioClip ScanExecuted;
        public AudioClip ScanBlocked;

        [Header("Claim")]
        public AudioClip ClaimSucceeded;
        public AudioClip ClaimFailed;

        [Header("Extract")]
        public AudioClip ExtractStart;
        public AudioClip ExtractStop;

        [Header("Discovery")]
        public AudioClip DepositDiscovered;

        [Header("Tuning")]
        [Range(0f, 1f)] public float MasterSfxVolume = 0.8f;
        [Range(0f, 1f)] public float ScanVolume = 0.9f;
        [Range(0f, 1f)] public float ClaimVolume = 0.9f;
        [Range(0f, 1f)] public float ExtractVolume = 0.7f;
        [Range(0f, 1f)] public float DiscoveryVolume = 0.85f;

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\DepositMarkerRenderer.cs =====
using System.Collections.Generic;
using UnityEngine;
using MineIt.Mining;
using MineIt.World;

namespace MineItUnity.Game
{
    /// <summary>
    /// Draws discovered deposit markers using pooled SpriteRenderers.
    /// - Only within camera bounds
    /// - Colors by ownership
    /// - No per-frame Instantiate/Destroy
    /// </summary>
    public sealed class DepositMarkerRenderer : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;

        [Header("Tuning")]
        public int SortingOrder = 30;              // above fog, below night overlay
        public float MarkerScale = 0.35f;          // relative to 1 tile = 1 unit
        public int CameraPaddingTiles = 2;
        public int InitialPoolSize = 256;

        // Colors (match your spec)
        public Color UnclaimedColor = new Color(0.2f, 1.0f, 1.0f, 1.0f);    // cyan
        public Color PlayerClaimedColor = new Color(0.2f, 1.0f, 0.2f, 1.0f); // green
        public Color NpcClaimedColor = new Color(1.0f, 0.35f, 0.1f, 1.0f);   // orange/red

        private Camera _cam;

        // Pooling
        private readonly Stack<SpriteRenderer> _pool = new Stack<SpriteRenderer>();
        private readonly Dictionary<int, SpriteRenderer> _activeByDepositId = new Dictionary<int, SpriteRenderer>();
        private readonly HashSet<int> _seenThisFrame = new HashSet<int>();

        private Sprite _circleSprite;

        private void Awake()
        {
            _cam = Camera.main;
            _circleSprite = CreateCircleSprite(16);

            WarmPool(InitialPoolSize);
        }

        private void LateUpdate()
        {
            if (Controller == null || Controller.Session == null) return;
            if (_cam == null) _cam = Camera.main;
            if (_cam == null || !_cam.orthographic) return;

            RenderMarkers();
        }

        private void RenderMarkers()
        {
            var session = Controller.Session;
            var chunks = session.Chunks;

            // Camera bounds in tile coords (1 Unity unit = 1 tile)
            float halfH = _cam.orthographicSize;
            float halfW = halfH * _cam.aspect;

            Vector3 camPos = _cam.transform.position;

            int minTx = Mathf.FloorToInt(camPos.x - halfW) - CameraPaddingTiles;
            int maxTx = Mathf.CeilToInt(camPos.x + halfW) + CameraPaddingTiles;
            int minTy = Mathf.FloorToInt(camPos.y - halfH) - CameraPaddingTiles;
            int maxTy = Mathf.CeilToInt(camPos.y + halfH) + CameraPaddingTiles;

            minTx = Mathf.Clamp(minTx, 0, chunks.WorldWidthTiles - 1);
            maxTx = Mathf.Clamp(maxTx, 0, chunks.WorldWidthTiles - 1);
            minTy = Mathf.Clamp(minTy, 0, chunks.WorldHeightTiles - 1);
            maxTy = Mathf.Clamp(maxTy, 0, chunks.WorldHeightTiles - 1);

            _seenThisFrame.Clear();

            // Iterate loaded chunks only
            foreach (var ch in chunks.GetLoadedChunks())
            {
                // Quick reject: if chunk AABB doesn't intersect camera bounds, skip
                int baseTx = ch.Coord.Cx * Chunk.CHUNK_SIZE_TILES;
                int baseTy = ch.Coord.Cy * Chunk.CHUNK_SIZE_TILES;
                int endTx = baseTx + Chunk.CHUNK_SIZE_TILES - 1;
                int endTy = baseTy + Chunk.CHUNK_SIZE_TILES - 1;

                if (endTx < minTx || baseTx > maxTx || endTy < minTy || baseTy > maxTy)
                    continue;

                // Chunk deposits list contains the authoritative deposit objects
                foreach (var d in ch.Deposits)
                {
                    if (!d.DiscoveredByPlayer) continue;
                    if (d.RemainingUnits <= 0) continue;

                    int tx = d.CenterTx;
                    int ty = d.CenterTy;

                    if (tx < minTx || tx > maxTx || ty < minTy || ty > maxTy)
                        continue;

                    _seenThisFrame.Add(d.DepositId);

                    var sr = GetOrCreateMarker(d.DepositId);

                    // Center marker in the tile
                    sr.transform.position = new Vector3(tx + 0.5f, ty + 0.5f, 0f);
                    sr.transform.localScale = new Vector3(MarkerScale, MarkerScale, 1f);

                    // Ownership color
                    if (d.ClaimedByPlayer) sr.color = PlayerClaimedColor;
                    else if (d.ClaimedByNpcId.HasValue) sr.color = NpcClaimedColor;
                    else sr.color = UnclaimedColor;
                }
            }

            // Deactivate any markers not seen this frame
            // (Use a temp list to avoid modifying dictionary during enumeration)
            if (_activeByDepositId.Count > 0)
            {
                _toRemove.Clear();
                foreach (var kv in _activeByDepositId)
                {
                    if (!_seenThisFrame.Contains(kv.Key))
                        _toRemove.Add(kv.Key);
                }

                for (int i = 0; i < _toRemove.Count; i++)
                {
                    int id = _toRemove[i];
                    ReturnToPool(id);
                }
            }
        }

        // Reused list to avoid allocations
        private readonly List<int> _toRemove = new List<int>(256);

        private SpriteRenderer GetOrCreateMarker(int depositId)
        {
            if (_activeByDepositId.TryGetValue(depositId, out var sr))
                return sr;

            sr = (_pool.Count > 0) ? _pool.Pop() : CreateMarkerRenderer();
            sr.gameObject.SetActive(true);
            _activeByDepositId[depositId] = sr;
            return sr;
        }

        private void ReturnToPool(int depositId)
        {
            if (!_activeByDepositId.TryGetValue(depositId, out var sr))
                return;

            _activeByDepositId.Remove(depositId);
            sr.gameObject.SetActive(false);
            _pool.Push(sr);
        }

        private void WarmPool(int count)
        {
            for (int i = 0; i < count; i++)
            {
                var sr = CreateMarkerRenderer();
                sr.gameObject.SetActive(false);
                _pool.Push(sr);
            }
        }

        private SpriteRenderer CreateMarkerRenderer()
        {
            var go = new GameObject("DepositMarker");
            go.transform.SetParent(transform, worldPositionStays: false);

            var sr = go.AddComponent<SpriteRenderer>();
            sr.sprite = _circleSprite;
            sr.sortingOrder = SortingOrder;
            sr.color = UnclaimedColor;

            return sr;
        }

        private static Sprite CreateCircleSprite(int sizePx)
        {
            var tex = new Texture2D(sizePx, sizePx, TextureFormat.RGBA32, false);
            tex.wrapMode = TextureWrapMode.Clamp;
            tex.filterMode = FilterMode.Point;

            float cx = (sizePx - 1) * 0.5f;
            float cy = (sizePx - 1) * 0.5f;
            float r = (sizePx * 0.5f) - 1f;
            float r2 = r * r;

            for (int y = 0; y < sizePx; y++)
                for (int x = 0; x < sizePx; x++)
                {
                    float dx = x - cx;
                    float dy = y - cy;
                    float d2 = dx * dx + dy * dy;

                    // Solid circle, transparent outside
                    float a = d2 <= r2 ? 1f : 0f;
                    tex.SetPixel(x, y, new Color(1f, 1f, 1f, a));
                }

            tex.Apply();
            return Sprite.Create(tex, new Rect(0, 0, sizePx, sizePx), new Vector2(0.5f, 0.5f), 1);
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\FogTilemapRenderer.cs =====
using UnityEngine;
using UnityEngine.Tilemaps;
using MineIt.Fog;

namespace MineItUnity.Game
{
    public sealed class FogTilemapRenderer : MonoBehaviour
    {
        public GameController Controller;

        public Tilemap FogBlackTilemap; // undiscovered
        public Tilemap FogDimTilemap;   // discovered-but-not-visible

        public TileBase FogTile;        // a solid black tile (sprite can be opaque)
        public int CameraPaddingTiles = 4;

        private void LateUpdate()
        {
            if (Controller == null) return;
            var session = Controller.Session;
            if (session == null) return;

            var cam = Camera.main;
            if (cam == null || !cam.orthographic) return;

            UpdateFogInCameraBounds(session.Fog, session, cam);
        }

        private void UpdateFogInCameraBounds(FogOfWar fog, MineIt.Simulation.GameSession session, Camera cam)
        {
            // Camera bounds in world units (1 Unity unit == 1 tile)
            float halfH = cam.orthographicSize;
            float halfW = halfH * cam.aspect;

            Vector3 camPos = cam.transform.position;

            int minTx = Mathf.FloorToInt(camPos.x - halfW) - CameraPaddingTiles;
            int maxTx = Mathf.CeilToInt(camPos.x + halfW) + CameraPaddingTiles;
            int minTy = Mathf.FloorToInt(camPos.y - halfH) - CameraPaddingTiles;
            int maxTy = Mathf.CeilToInt(camPos.y + halfH) + CameraPaddingTiles;

            // Clamp to world
            minTx = Mathf.Clamp(minTx, 0, fog.Width - 1);
            maxTx = Mathf.Clamp(maxTx, 0, fog.Width - 1);
            minTy = Mathf.Clamp(minTy, 0, fog.Height - 1);
            maxTy = Mathf.Clamp(maxTy, 0, fog.Height - 1);

            for (int ty = minTy; ty <= maxTy; ty++)
                for (int tx = minTx; tx <= maxTx; tx++)
                {
                    var cell = new Vector3Int(tx, ty, 0);

                    if (!fog.IsDiscovered(tx, ty))
                    {
                        FogBlackTilemap.SetTile(cell, FogTile);
                        FogDimTilemap.SetTile(cell, null);
                    }
                    else if (!fog.IsVisibleNow(tx, ty))
                    {
                        FogBlackTilemap.SetTile(cell, null);
                        FogDimTilemap.SetTile(cell, FogTile);
                    }
                    else
                    {
                        FogBlackTilemap.SetTile(cell, null);
                        FogDimTilemap.SetTile(cell, null);
                    }
                }
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\GameController.cs =====
using UnityEngine;
using MineIt.Simulation;
using MineIt.Input;
using System.IO;
using MineItUnity.Game.Map;

namespace MineItUnity.Game
{
    public sealed class GameController : MonoBehaviour
    {
        private const double FixedDt = 1.0 / 60.0;
        private double _accumulator;

        private GameSession _session = null!;
        public GameSession Session => _session;

        private Transform _playerMarker = null!;

        [Header("Optional References")]
        public WaypointManager Waypoints;
        public WorldMapController Map;

        private void Awake()
        {
            Screen.fullScreenMode = FullScreenMode.FullScreenWindow;
            Screen.fullScreen = true;

            Application.targetFrameRate = 60;

            _session = new GameSession();
            _session.InitializeNewGame(seed: 12345);

            if (Waypoints == null)
                Waypoints = FindObjectOfType<WaypointManager>();

            if (Map == null)
                Map = FindObjectOfType<WorldMapController>();

            // Simple player marker (placeholder sprite)
            var go = new GameObject("PlayerMarker");
            _playerMarker = go.transform;

            var sr = go.AddComponent<SpriteRenderer>();
            sr.sprite = CreateDebugSprite();
            sr.sortingOrder = 10;
        }

        private void Update()
        {
            _accumulator += Time.unscaledDeltaTime;
            if (_accumulator > 0.25) _accumulator = 0.25;

            var input = BuildInputSnapshot();

            // ---- Quit handling (ESC) ----
            if (UnityEngine.Input.GetKeyDown(KeyCode.Escape))
            {
#if UNITY_EDITOR
                Debug.Log("Quit requested (ESC) — ignored in Editor");
#else
            Application.Quit();
#endif
            }

            // ---- Save / Load (F5 / F9) ----
            if (UnityEngine.Input.GetKeyDown(KeyCode.F5))
                SaveGame();

            if (UnityEngine.Input.GetKeyDown(KeyCode.F9))
                LoadGame();

            // ---- Debug: toggle artifact overlay on map (F1) ----
            if (UnityEngine.Input.GetKeyDown(KeyCode.F1))
            {
                try
                {
                    string report = _session.Deposits.GetArtifactSpawnsDebugReport();
                    Debug.Log(report);

                    if (Map != null)
                    {
                        bool newState = !Map.DebugShowArtifacts;
                        Map.DebugSetArtifactsOverlay(newState, openMap: true);
                        _session.PostStatus(newState ? "DEBUG: Artifacts ON (map)" : "DEBUG: Artifacts OFF", 2.0);
                    }
                    else
                    {
                        _session.PostStatus("DEBUG: Map not found (cannot show artifacts)", 2.5);
                    }
                }
                catch (System.Exception ex)
                {
                    _session.PostStatus($"ARTIFACT DEBUG FAILED: {ex.Message}", 2.5);
                }
            }


            bool oneShotConsumed = false;
            while (_accumulator >= FixedDt)
            {
                var stepInput = input;

                if (oneShotConsumed)
                {
                    stepInput = new InputSnapshot
                    {
                        MoveUp = input.MoveUp,
                        MoveDown = input.MoveDown,
                        MoveLeft = input.MoveLeft,
                        MoveRight = input.MoveRight,

                        ScanPressed = false,
                        ClaimPressed = false,
                        ExtractPressed = false,
                        DepositPressed = false,
                        SellPressed = false,

                        DevSetDetectorTier = 0,
                        DevSetExtractorTier = 0,
                        DevSetBackpackTier = 0,
                    };
                }

                _session.Update(FixedDt, stepInput);
                _accumulator -= FixedDt;
                oneShotConsumed = true;
            }

            // Present: 1 Unity unit = 1 tile (for now)
            _playerMarker.position = new Vector3(
                (float)_session.Player.PositionX,
                (float)_session.Player.PositionY,
                0f);

            // Camera follow
            if (Camera.main != null)
            {
                var cam = Camera.main.transform;
                cam.position = new Vector3(_playerMarker.position.x, _playerMarker.position.y, cam.position.z);
            }

        }


        private string SavePath => System.IO.Path.Combine(Application.persistentDataPath, "MineIt.save.json");

        private void SaveGame()
        {
            try
            {
                var data = MineIt.Save.SaveGameSerializer.SaveToData(_session);

                // Waypoint persistence (Unity-owned)
                if (Waypoints != null && Waypoints.HasWaypoint)
                {
                    data.HasWaypoint = true;
                    data.WaypointTx = Waypoints.WaypointTx;
                    data.WaypointTy = Waypoints.WaypointTy;
                }
                else
                {
                    data.HasWaypoint = false;
                    data.WaypointTx = 0;
                    data.WaypointTy = 0;
                }

                string json = MineIt.Save.SaveGameSerializer.ToJson(data, prettyPrint: true);
                System.IO.File.WriteAllText(SavePath, json);

                _session.PostStatus($"SAVE OK ({SavePath})", 1.5);
            }
            catch (System.Exception ex)
            {
                _session.PostStatus($"SAVE FAILED: {ex.Message}", 2.5);
            }
        }

        private void LoadGame()
        {
            try
            {
                if (!System.IO.File.Exists(SavePath))
                {
                    _session.PostStatus("LOAD FAILED: no save file", 2.5);
                    return;
                }

                string json = System.IO.File.ReadAllText(SavePath);
                var data = MineIt.Save.SaveGameSerializer.LoadFromJson(json);

                _session.LoadFromSave(data);

                _session.PostStatus("LOAD OK", 1.5);

                // Restore waypoint (Unity-owned)
                if (Waypoints != null)
                {
                    if (data.HasWaypoint)
                        Waypoints.SetWaypoint(data.WaypointTx, data.WaypointTy);
                    else
                        Waypoints.ClearWaypoint();
                }

            }
            catch (System.Exception ex)
            {
                _session.PostStatus($"LOAD FAILED: {ex.Message}", 2.5);
            }
        }



        private static InputSnapshot BuildInputSnapshot()
        {
            // Unity Y+ is up, core Y+ is down → invert here
            bool up = UnityEngine.Input.GetKey(KeyCode.S) || UnityEngine.Input.GetKey(KeyCode.DownArrow);
            bool down = UnityEngine.Input.GetKey(KeyCode.W) || UnityEngine.Input.GetKey(KeyCode.UpArrow);
            bool left = UnityEngine.Input.GetKey(KeyCode.A) || UnityEngine.Input.GetKey(KeyCode.LeftArrow);
            bool right = UnityEngine.Input.GetKey(KeyCode.D) || UnityEngine.Input.GetKey(KeyCode.RightArrow);

            bool scan = UnityEngine.Input.GetKeyDown(KeyCode.Space);
            bool claim = UnityEngine.Input.GetKeyDown(KeyCode.C);
            bool extract = UnityEngine.Input.GetKeyDown(KeyCode.E);
            bool deposit = UnityEngine.Input.GetKeyDown(KeyCode.T);
            bool sell = UnityEngine.Input.GetKeyDown(KeyCode.Y);

            int tierKey = KeyToTierNumber();
            int det = 0, ext = 0, bag = 0;

            if (tierKey != 0)
            {
                bool shift = UnityEngine.Input.GetKey(KeyCode.LeftShift) || UnityEngine.Input.GetKey(KeyCode.RightShift);
                bool ctrl = UnityEngine.Input.GetKey(KeyCode.LeftControl) || UnityEngine.Input.GetKey(KeyCode.RightControl);

                if (ctrl) bag = tierKey;
                else if (shift) ext = tierKey;
                else det = tierKey;
            }

            return new InputSnapshot
            {
                MoveUp = up,
                MoveDown = down,
                MoveLeft = left,
                MoveRight = right,

                ScanPressed = scan,
                ClaimPressed = claim,
                ExtractPressed = extract,
                DepositPressed = deposit,
                SellPressed = sell,

                DevSetDetectorTier = det,
                DevSetExtractorTier = ext,
                DevSetBackpackTier = bag,
            };
        }

        private static int KeyToTierNumber()
        {
            if (UnityEngine.Input.GetKeyDown(KeyCode.Alpha1) || UnityEngine.Input.GetKeyDown(KeyCode.Keypad1)) return 1;
            if (UnityEngine.Input.GetKeyDown(KeyCode.Alpha2) || UnityEngine.Input.GetKeyDown(KeyCode.Keypad2)) return 2;
            if (UnityEngine.Input.GetKeyDown(KeyCode.Alpha3) || UnityEngine.Input.GetKeyDown(KeyCode.Keypad3)) return 3;
            if (UnityEngine.Input.GetKeyDown(KeyCode.Alpha4) || UnityEngine.Input.GetKeyDown(KeyCode.Keypad4)) return 4;
            if (UnityEngine.Input.GetKeyDown(KeyCode.Alpha5) || UnityEngine.Input.GetKeyDown(KeyCode.Keypad5)) return 5;
            return 0;
        }

        private static Sprite CreateDebugSprite()
        {
            var tex = new Texture2D(1, 1, TextureFormat.RGBA32, false);
            tex.SetPixel(0, 0, Color.white);
            tex.Apply();

            return Sprite.Create(tex, new Rect(0, 0, 1, 1), new Vector2(0.5f, 0.5f), 1);
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\HudController.cs =====
using System.Text;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using MineIt.Inventory;
using MineIt.Mining;

namespace MineItUnity.Game
{
    /// <summary>
    /// MVP HUD: single TextMeshPro block updated at a fixed rate (cheap).
    /// Reads state from GameSession; does not mutate game state.
    /// </summary>
    public sealed class HudController : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;
        public TextMeshProUGUI HudText;

        [Header("Bars (Optional UI Images)")]
        [Tooltip("Parent GameObject for claim bar (enable/disable). Optional.")]
        public GameObject ClaimBarRoot;

        [Tooltip("Fill Image for claim bar (Image Type must be Filled / Horizontal). Optional.")]
        public Image ClaimBarFill;

        [Tooltip("Parent GameObject for scan cooldown bar (enable/disable). Optional.")]
        public GameObject ScanBarRoot;

        [Tooltip("Fill Image for scan cooldown bar (Image Type must be Filled / Horizontal). Optional.")]
        public Image ScanBarFill;

        [Tooltip("Parent GameObject for backpack bar. Optional.")]
        public GameObject BackpackBarRoot;

        [Tooltip("Fill Image for backpack bar (Image Type must be Filled / Horizontal). Optional.")]
        public Image BackpackBarFill;

        [Tooltip("If true, backpack bar only shows while extracting; otherwise it is always visible.")]
        public bool ShowBackpackBarOnlyWhileExtracting = false;

        [Header("Update Rate")]
        [Tooltip("HUD refreshes at this rate (Hz). 10 is plenty and reduces allocations.")]
        public float UpdatesPerSecond = 10f;

        private float _nextUpdateTime;
        private readonly StringBuilder _sb = new StringBuilder(1024);

        private void Awake()
        {
            if (UpdatesPerSecond < 1f) UpdatesPerSecond = 1f;
            _nextUpdateTime = 0f;
        }

        private static readonly string[] RequiredArtifacts =
{
    "stellar_shard",
    "ancient_lattice",
    "void_compass",
    "quantum_fossil",
    "machine_relic",
    "echo_prism"
};


        private void Update()
        {
            if (Controller == null || Controller.Session == null || HudText == null)
                return;

            // Bars should update smoothly every frame (no allocations).
            UpdateBars(Controller.Session);

            if (Time.unscaledTime < _nextUpdateTime)
                return;

            _nextUpdateTime = Time.unscaledTime + (1f / UpdatesPerSecond);

            var s = Controller.Session;
            BuildHudText(s);
            HudText.text = _sb.ToString();
        }

        private void BuildHudText(MineIt.Simulation.GameSession s)
        {
            _sb.Clear();

            // Time
            double hours = s.Clock.InGameHours;
            int hh = (int)hours;
            int mm = (int)((hours - hh) * 60.0);
            if (mm < 0) mm = 0;
            if (mm > 59) mm = 59;

            bool night = s.Clock.IsNight;
            double dark01 = s.Clock.Darkness01;

            int pTx = Mathf.FloorToInt((float)s.Player.PositionX);
            int pTy = Mathf.FloorToInt((float)s.Player.PositionY);

            int chunkSize = MineIt.World.Chunk.CHUNK_SIZE_TILES;
            int cX = pTx / chunkSize;
            int cY = pTy / chunkSize;

            _sb.Append("Time ")
               .Append(hh.ToString("00")).Append(':').Append(mm.ToString("00"))
               .Append("   ").Append(night ? "NIGHT" : "DAY")
               .Append("   Darkness ").Append((dark01 * 100.0).ToString("0")).Append('%')
               .AppendLine();

            _sb.Append("Player Tile (").Append(pTx).Append(',').Append(pTy).Append(")")
               .Append("   Chunk (").Append(cX).Append(',').Append(cY).Append(')')
               .AppendLine();

            // Detector + Extractor
            int detTier = s.Player.DetectorTier;
            int detRad = s.Player.DetectorRadiusTiles;
            int detDepth = s.Player.DetectorMaxDepthMeters;

            int exTier = s.Player.ExtractorTier;
            int exRange = s.Player.ExtractorRangeTiles;
            int exDepth = s.Player.ExtractorMaxDepthMeters;
            double exRate = s.Player.ExtractorRateKgPerSec;

            _sb.Append("Detector T").Append(detTier)
               .Append("   R ").Append(detRad).Append("   D ").Append(detDepth).Append("m")
               .AppendLine();

            _sb.Append("Extractor T").Append(exTier)
               .Append("   R ").Append(exRange).Append("   D ").Append(exDepth).Append("m")
               .Append("   ").Append(exRate.ToString("0.0")).Append("kg/s")
               .AppendLine();

            // Scan intelligence
            var results = s.LastScanResults;
            int hits = results != null ? results.Count : 0;
            _sb.Append("Scan Hits: ").Append(hits).AppendLine();

            if (results != null && results.Count > 0)
            {
                int show = Mathf.Min(3, results.Count);

                for (int i = 0; i < show; i++)
                {
                    var r = results[i];

                    int dx = r.CenterTx - pTx;
                    int dy = r.CenterTy - pTy;
                    int dist = Mathf.RoundToInt(Mathf.Sqrt(dx * dx + dy * dy));

                    bool npcMining = false;
                    var dep = s.Deposits.TryGetDepositById(r.DepositId);
                    if (dep != null && dep.ClaimedByNpcId.HasValue)
                        npcMining = true;

                    _sb.Append(i == 0 ? "▶ " : "  ");
                    _sb.Append(r.OreTypeId.ToUpper())
                       .Append("  ")
                       .Append(r.EstimatedSizeClass)
                       .Append("  ")
                       .Append(dist).Append("t");

                    if (npcMining)
                        _sb.Append("  NPC");

                    if (r.DepthMeters > s.Player.DetectorMaxDepthMeters)
                        _sb.Append("  DEEP");

                    _sb.AppendLine();
                }
            }

            // Backpack + Credits
            if (s.Backpack != null)
            {
                _sb.Append("Backpack: ")
                   .Append(s.Backpack.CurrentKg.ToString("0.0"))
                   .Append('/')
                   .Append(s.Backpack.CapacityKg.ToString("0.0"))
                   .Append(" kg")
                   .AppendLine();
            }

            _sb.Append("Credits: ").Append(s.Credits).AppendLine();

            // --- Artifact progress (always visible) ---
            int have = 0;
            for (int i = 0; i < RequiredArtifacts.Length; i++)
            {
                if (s.TownStorage != null && s.TownStorage.HasArtifact(RequiredArtifacts[i]))
                    have++;
            }

            _sb.Append("Artifacts: ")
               .Append(have)
               .Append('/')
               .Append(RequiredArtifacts.Length);

            if (s.HasWon)
            {
                _sb.Append("  COMPLETE");
            }
            else if (s.VaultAuthInProgress)
            {
                _sb.Append("  Authenticating ")
                   .Append(Mathf.CeilToInt((float)s.VaultAuthRemainingSeconds))
                   .Append("s");
            }

            _sb.AppendLine();


            // Cooldowns / channels (text-only MVP)
            if (s.ScanCooldownMaxSeconds > 0.0001)
            {
                if (s.ScanCooldownRemainingSeconds > 0.0)
                    _sb.Append("Scan CD: ").Append(s.ScanCooldownRemainingSeconds.ToString("0.0")).Append("s").AppendLine();
                else
                    _sb.Append("Scan READY").AppendLine();
            }

            if (s.ClaimInProgress)
            {
                _sb.Append("Claiming: ").Append(s.ClaimChannelRemainingSeconds.ToString("0.0")).Append("s").AppendLine();
            }

            if (s.ExtractInProgress)
            {
                // Rich extraction status
                var d = s.Deposits.TryGetDepositById(s.ExtractTargetDepositId);

                _sb.Append("EXTRACTING (E to stop)").AppendLine();

                if (d != null)
                {
                    // Effective rate accounts for ore difficulty (matches core extraction math)
                    double diff = OreCatalog.ExtractionDifficulty(d.OreTypeId);
                    if (diff < 1e-6) diff = 1.0;

                    double effRate = s.Player.ExtractorRateKgPerSec / diff;

                    _sb.Append("  Ore: ").Append(d.OreTypeId)
                       .Append("   Depth: ").Append(d.DepthMeters).Append("m")
                       .AppendLine();

                    _sb.Append("  Remaining: ").Append(d.RemainingUnits).Append(" units")
                       .AppendLine();

                    // --- Depletion ETA (player extraction) ---
                    double rate = s.Player.ExtractorRateKgPerSec /
                                  MineIt.Inventory.OreCatalog.ExtractionDifficulty(d.OreTypeId);

                    double etaSec = d.EstimateSecondsToDeplete(rate);

                    _sb.Append("  ETA: ")
                       .Append(FormatEta(etaSec))
                       .AppendLine();

                    _sb.Append("  Rate: ").Append(effRate.ToString("0.00")).Append(" kg/s")
                       .Append("   Carry: ").Append(s.ExtractKgRemainder.ToString("0.00")).Append(" kg")
                       .AppendLine();

                    if (s.Backpack != null && s.Backpack.CapacityKg > 1e-9)
                    {
                        double pct = (s.Backpack.CurrentKg / s.Backpack.CapacityKg) * 100.0;
                        _sb.Append("  Backpack: ")
                           .Append(pct.ToString("0")).Append("%")
                           .AppendLine();
                    }
                }
                else
                {
                    _sb.Append("  (target deposit not found)").AppendLine();
                }
            }

            // --- NPC mining feedback (for discovered deposits) ---
            // Show at most one line, but do NOT return from BuildHudText (or we suppress prompts/Last:).
            bool printedNpcLine = false;

            foreach (var ch in s.Chunks.GetLoadedChunks())
            {
                foreach (var dep in ch.Deposits)
                {
                    if (!dep.DiscoveredByPlayer) continue;
                    if (!dep.ClaimedByNpcId.HasValue) continue;
                    if (dep.RemainingUnits <= 0) continue;

                    NpcMinerManager.NpcMiner npc = null;

                    var npcList = s.Npcs?.Npcs;
                    if (npcList == null) continue;

                    for (int i = 0; i < npcList.Count; i++)
                    {
                        if (npcList[i].NpcId == dep.ClaimedByNpcId.Value)
                        {
                            npc = npcList[i];
                            break;
                        }
                    }

                    if (npc == null) continue;

                    double rate = s.Npcs.GetNpcExtractionRateKgPerSec(npc, dep.OreTypeId);
                    double eta = dep.EstimateSecondsToDeplete(rate);

                    _sb.Append("NPC mining ")
                       .Append(dep.OreTypeId)
                       .Append(" — ETA ")
                       .Append(FormatEta(eta))
                       .AppendLine();

                    printedNpcLine = true;
                    break; // stop after one line
                }

                if (printedNpcLine)
                    break;
            }



            // Prompts
            if (s.CanClaimNow && !s.ClaimInProgress)
                _sb.Append("C to Claim").AppendLine();

            if (s.CanExtractNow && !s.ExtractInProgress)
            {
                _sb.Append("E to Extract").AppendLine();

                // Show candidate details to reduce ambiguity
                var cand = s.Deposits.TryGetDepositById(s.ExtractCandidateDepositId);
                if (cand != null)
                {
                    _sb.Append("  Target: ").Append(cand.OreTypeId)
                       .Append("   Depth ").Append(cand.DepthMeters).Append("m")
                       .Append("   Remaining ").Append(cand.RemainingUnits).Append("u")
                       .AppendLine();
                }
            }

            if (s.IsInTownZone)
            {
                _sb.Append("T to Deposit Ore").AppendLine();
                _sb.Append("Y to Sell Ore").AppendLine();
                _sb.Append("Upgrades: 1-5 Detector | Shift+1-5 Extractor | Ctrl+1-5 Backpack").AppendLine();
            }

            // Last action (debug)
            if (s.LastActionFlashSeconds > 0 && !string.IsNullOrEmpty(s.LastActionText))
            {
                _sb.Append("Last: ").Append(s.LastActionText).AppendLine();
            }
        }

        private static string FormatEta(double seconds)
        {
            if (double.IsInfinity(seconds)) return "∞";
            if (seconds <= 0) return "0s";

            if (seconds < 60)
                return $"{Mathf.CeilToInt((float)seconds)}s";

            int mins = Mathf.FloorToInt((float)(seconds / 60.0));
            int secs = Mathf.CeilToInt((float)(seconds - mins * 60));
            return $"{mins}m {secs:00}s";
        }

        private void UpdateBars(MineIt.Simulation.GameSession s)
        {
            // ---- Claim progress ----
            if (ClaimBarRoot != null && ClaimBarFill != null)
            {
                bool active = s.ClaimInProgress;
                if (ClaimBarRoot.activeSelf != active)
                    ClaimBarRoot.SetActive(active);

                if (active)
                {
                    // progress = 1 - remaining/total
                    double total = MineIt.Simulation.GameSession.ClaimChannelTotalSeconds;
                    double rem = s.ClaimChannelRemainingSeconds;

                    float p = 0f;
                    if (total > 1e-6)
                        p = Mathf.Clamp01((float)(1.0 - (rem / total)));

                    ClaimBarFill.fillAmount = p;
                }
                else
                {
                    ClaimBarFill.fillAmount = 0f;
                }
            }

            // ---- Scan cooldown progress ----
            if (ScanBarRoot != null && ScanBarFill != null)
            {
                // Show bar when cooling down; hide when ready.
                bool cooling = s.ScanCooldownRemainingSeconds > 0.0 && s.ScanCooldownMaxSeconds > 1e-6;
                if (ScanBarRoot.activeSelf != cooling)
                    ScanBarRoot.SetActive(cooling);

                if (cooling)
                {
                    // progress = 1 - remaining/max
                    double p01 = 1.0 - (s.ScanCooldownRemainingSeconds / s.ScanCooldownMaxSeconds);
                    ScanBarFill.fillAmount = Mathf.Clamp01((float)p01);
                }
                else
                {
                    ScanBarFill.fillAmount = 1f; // visually "ready" if you ever show it
                }
            }

            // ---- Backpack fill (extraction feedback) ----
            if (BackpackBarRoot != null && BackpackBarFill != null && s.Backpack != null)
            {
                bool active = ShowBackpackBarOnlyWhileExtracting ? s.ExtractInProgress : true;

                if (BackpackBarRoot.activeSelf != active)
                    BackpackBarRoot.SetActive(active);

                if (active)
                {
                    double cap = s.Backpack.CapacityKg;
                    double cur = s.Backpack.CurrentKg;

                    float p = 0f;
                    if (cap > 1e-9) p = Mathf.Clamp01((float)(cur / cap));

                    BackpackBarFill.fillAmount = p;
                }
                else
                {
                    BackpackBarFill.fillAmount = 0f;
                }
            }

        }


    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\Map\AutoWaypointOnScan.cs =====
using UnityEngine;
using MineIt.Mining;

namespace MineItUnity.Game.Map
{
    /// <summary>
    /// Auto-sets a waypoint after a scan executes, but ONLY if no waypoint is currently set.
    /// Presentation-only: reads core scan results and drives Unity-owned waypoint state.
    /// </summary>
    public sealed class AutoWaypointOnScanController : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;
        public WaypointManager Waypoints;

        [Header("Behavior")]
        [Tooltip("If true, auto-waypoint runs even if the map is open. If false, we skip while map is open.")]
        public bool AllowWhileMapOpen = false;

        [Tooltip("If true, auto-waypoint will only fire when scan returns at least one hit.")]
        public bool RequireAtLeastOneHit = true;

        private bool _subscribed;

        private void Awake()
        {
            if (Controller == null)
                Controller = FindObjectOfType<GameController>();

            if (Waypoints == null)
                Waypoints = FindObjectOfType<WaypointManager>();
        }

        private void OnEnable()
        {
            TrySubscribe();
        }

        private void OnDisable()
        {
            Unsubscribe();
        }

        private void Update()
        {
            // In case script enable order is weird, keep trying until we succeed.
            if (!_subscribed)
                TrySubscribe();
        }

        private void TrySubscribe()
        {
            if (_subscribed) return;
            if (Controller == null || Controller.Session == null) return;

            Controller.Session.ScanExecuted += OnScanExecuted;
            _subscribed = true;
        }

        private void Unsubscribe()
        {
            if (!_subscribed) return;
            if (Controller == null || Controller.Session == null) { _subscribed = false; return; }

            Controller.Session.ScanExecuted -= OnScanExecuted;
            _subscribed = false;
        }

        private void OnScanExecuted()
        {
            if (Controller == null || Controller.Session == null) return;
            if (Waypoints == null) return;

            // Only if no waypoint is set already
            if (Waypoints.HasWaypoint) return;

            // Optional: skip while map open (prevents surprise UI changes)
            if (!AllowWhileMapOpen && Waypoints.IsMapOpen) return;

            var s = Controller.Session;
            var results = s.LastScanResults;

            if (results == null) return;
            if (RequireAtLeastOneHit && results.Count == 0) return;

            // Choose best target:
            // 1) highest signal bars
            // 2) nearest to player (tile distance)
            int pTx = Mathf.FloorToInt((float)s.Player.PositionX);
            int pTy = Mathf.FloorToInt((float)s.Player.PositionY);

            int bestBars = -1;
            int bestDist2 = int.MaxValue;
            int bestTx = 0, bestTy = 0;
            bool found = false;

            for (int i = 0; i < results.Count; i++)
            {
                ScanResult r = results[i];
                if (r == null) continue;

                int tx = r.CenterTx;
                int ty = r.CenterTy;

                int dx = tx - pTx;
                int dy = ty - pTy;
                int dist2 = dx * dx + dy * dy;

                int bars = r.SignalBars;

                if (!found ||
                    bars > bestBars ||
                    (bars == bestBars && dist2 < bestDist2))
                {
                    found = true;
                    bestBars = bars;
                    bestDist2 = dist2;
                    bestTx = tx;
                    bestTy = ty;
                }
            }

            if (!found) return;

            Waypoints.SetWaypoint(bestTx, bestTy);

            // Optional user feedback (core HUD status line)
            s.PostStatus($"AUTO WAYPOINT: Scan target ({bestBars} bars)", 1.5);
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\Map\CompassArrowController.cs =====
using UnityEngine;
using UnityEngine.UI;
using TMPro;

namespace MineItUnity.Game.Map
{
    /// <summary>
    /// Displays a simple compass arrow pointing from player toward the waypoint.
    /// UI-only: does not affect simulation.
    /// </summary>
    public sealed class CompassArrowController : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;
        public WaypointManager Waypoints;

        [Header("UI")]
        public RectTransform ArrowRoot;
        public Image ArrowImage;

        [Tooltip("Optional distance text (tiles).")]
        public TextMeshProUGUI DistanceText;

        [Header("Tuning")]
        public float ArrowRadiusPixels = 120f; // distance from screen center
        public float ArrowSizePixels = 36f;    // arrow icon size

        private void Awake()
        {
            if (ArrowImage != null && ArrowImage.sprite == null)
                ArrowImage.sprite = CreateArrowSprite(64, 64);
        }

        private void Update()
        {
            if (Controller == null || Controller.Session == null || Waypoints == null || ArrowRoot == null || ArrowImage == null)
                return;

            bool active = Waypoints.HasWaypoint && !Waypoints.IsMapOpen;

            // Never disable the controller GameObject; just toggle visuals
            if (ArrowImage != null) ArrowImage.enabled = active;
            if (DistanceText != null) DistanceText.enabled = active;

            if (!active)
            {
                if (DistanceText != null) DistanceText.text = "";
                return;
            }

            float px = (float)Controller.Session.Player.PositionX;
            float py = (float)Controller.Session.Player.PositionY;

            float wx = Waypoints.WaypointTx + 0.5f;
            float wy = Waypoints.WaypointTy + 0.5f;

            Vector2 dir = new Vector2(wx - px, wy - py);
            float dist = dir.magnitude;

            if (dist < 0.001f)
            {
                // On top of waypoint
                ArrowRoot.anchoredPosition = Vector2.zero;
                ArrowImage.rectTransform.localRotation = Quaternion.identity;
                if (DistanceText != null) DistanceText.text = "0";
                return;
            }

            dir /= dist;

            // Place arrow around center
            ArrowRoot.anchoredPosition = dir * ArrowRadiusPixels;

            // Rotate arrow to point toward waypoint
            float angleDeg = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
            ArrowImage.rectTransform.localRotation = Quaternion.Euler(0f, 0f, angleDeg - 90f);

            // Size
            ArrowImage.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, ArrowSizePixels);
            ArrowImage.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, ArrowSizePixels);

            // Distance in tiles
            if (DistanceText != null)
                DistanceText.text = $"{Mathf.RoundToInt(dist)}";
        }

        private static Sprite CreateArrowSprite(int w, int h)
        {
            // Simple triangle arrow (white)
            var tex = new Texture2D(w, h, TextureFormat.RGBA32, false);
            tex.wrapMode = TextureWrapMode.Clamp;
            tex.filterMode = FilterMode.Bilinear;

            Color clear = new Color(1f, 1f, 1f, 0f);
            Color solid = new Color(1f, 1f, 1f, 1f);

            for (int y = 0; y < h; y++)
                for (int x = 0; x < w; x++)
                    tex.SetPixel(x, y, clear);

            // Triangle pointing up
            int cx = w / 2;
            int top = h - 4;
            int baseY = 8;

            for (int y = baseY; y <= top; y++)
            {
                float t = (float)(y - baseY) / (top - baseY);
                int half = Mathf.RoundToInt(Mathf.Lerp(w * 0.30f, 0f, t));
                int x0 = cx - half;
                int x1 = cx + half;

                for (int x = x0; x <= x1; x++)
                {
                    if (x >= 0 && x < w)
                        tex.SetPixel(x, y, solid);
                }
            }

            tex.Apply();
            return Sprite.Create(tex, new Rect(0, 0, w, h), new Vector2(0.5f, 0.5f), 100f);
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\Map\WaypointManager.cs =====
using UnityEngine;

namespace MineItUnity.Game.Map
{
    /// <summary>
    /// Presentation-layer waypoint state (Unity-side).
    /// Shared by map (click-to-set) and world compass arrow.
    /// </summary>
    public sealed class WaypointManager : MonoBehaviour
    {
        public bool HasWaypoint { get; private set; }
        public int WaypointTx { get; private set; }
        public int WaypointTy { get; private set; }
        // Set by WorldMapController so other UI (compass) can react.
        public bool IsMapOpen { get; set; }

        public void SetWaypoint(int tx, int ty)
        {
            HasWaypoint = true;
            WaypointTx = tx;
            WaypointTy = ty;
        }

        public void ClearWaypoint()
        {
            HasWaypoint = false;
            WaypointTx = 0;
            WaypointTy = 0;
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\Map\WorldMapController.cs =====
using MineIt.Mining;
using MineIt.Simulation;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace MineItUnity.Game.Map
{
    /// <summary>
    /// Full-screen fog-aware world map overlay (M toggles).
    /// Unity-only presentation: reads GameSession state, does not mutate core.
    /// </summary>
    public sealed class WorldMapController : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;

        [Tooltip("Root panel GameObject to enable/disable when map is shown.")]
        public GameObject MapRoot;

        [Tooltip("RawImage that displays the generated map texture.")]
        public RawImage MapImage;

        [Tooltip("Waypoint state shared with compass arrow.")]
        public WaypointManager Waypoints;

        [Tooltip("Optional legend text (TextMeshProUGUI) displayed while map is open.")]
        public TextMeshProUGUI LegendText;

        [Tooltip("Optional: if present, we hide/show via CanvasGroup to keep layout stable in edit mode.")]
        public CanvasGroup MapCanvasGroup;

        [Header("Input")]
        public KeyCode ToggleKey = KeyCode.M;

        [Header("Update Rate")]
        [Tooltip("Map refreshes at this rate (Hz) while visible.")]
        public float UpdatesPerSecond = 10f;

        [Header("Colors")]
        public Color32 Undiscovered = new Color32(0, 0, 0, 255);
        public Color32 Discovered = new Color32(40, 40, 40, 255);
        public Color32 VisibleNow = new Color32(90, 90, 90, 255);

        public Color32 PlayerColor = new Color32(255, 255, 255, 255);

        public Color32 DepositUnclaimed = new Color32(50, 255, 255, 255);   // cyan
        public Color32 DepositPlayer = new Color32(50, 255, 50, 255);       // green
        public Color32 DepositNpc = new Color32(255, 90, 30, 255);          // orange/red

        [Header("DEBUG: Artifacts")]
        public bool DebugShowArtifacts = false;

        [Tooltip("If true, left-clicking an artifact marker while map is open teleports player there (DEBUG ONLY).")]
        public bool DebugClickTeleportsToArtifact = true;

        [Tooltip("How close (in tiles) a click must be to an artifact point to count.")]
        public int DebugArtifactClickRadiusTiles = 8;

        public Color32 ArtifactDebugColor = new Color32(255, 0, 255, 255); // magenta
        public int ArtifactDotRadius = 3;


        [Header("Waypoint")]
        public bool AllowWaypoint = true;
        public Color32 WaypointColor = new Color32(80, 170, 255, 255); // blue
        public int WaypointDotRadius = 3;

        [Header("Deposit Click Waypoint")]
        public bool DepositClickSetsWaypoint = true;

        [Tooltip("How close (in tiles) a click must be to a deposit center to count as clicking it.")]
        public int DepositClickRadiusTiles = 5;


        [Header("Town")]
        public bool ShowTownMarker = true;
        public Color32 TownColor = new Color32(255, 220, 60, 255); // yellow
        public int TownDotRadius = 3;

        [Header("Fast Travel")]
        public bool AllowFastTravelToTown = true;

        [Tooltip("Optional hotkey to fast travel to town while map is open.")]
        public KeyCode FastTravelKey = KeyCode.F;

        [Tooltip("How close (in tiles) a click must be to the town marker to count as clicking town.")]
        public int TownClickRadiusTiles = 6;

        [Tooltip("Credits required to fast travel to town.")]
        public int FastTravelCostCredits = 10;

        [Header("Marker Sizes")]
        [Tooltip("Radius in pixels for the player dot.")]
        public int PlayerDotRadius = 2;

        [Header("Depletion Warning")]
        public double DepletionWarningSeconds = 120.0; // 2 minutes

        [Tooltip("Radius in pixels for deposit dots.")]
        public int DepositDotRadius = 2;

        private Texture2D _tex;
        private Color32[] _pixels;
        private float _nextUpdateTime;

        private bool _visible;

        private void Awake()
        {
            if (UpdatesPerSecond < 1f) UpdatesPerSecond = 1f;

            SetVisible(false);
        }

        private void Update()
        {
            if (UnityEngine.Input.GetKeyDown(ToggleKey))
            {
                SetVisible(!_visible);
            }

            if (!_visible) return;

            if (Controller == null || Controller.Session == null) return;
            if (MapRoot == null || MapImage == null) return;

            // --- Fast travel hotkey (map open) ---
            if (AllowFastTravelToTown && UnityEngine.Input.GetKeyDown(FastTravelKey))
            {
                FastTravelToTown();
                return; // prevents other click logic from running this frame
            }

            // --- Fast travel click consumes left-click when clicking town marker ---
            if (AllowFastTravelToTown && UnityEngine.Input.GetMouseButtonDown(0))
            {
                if (TryGetMapTileUnderMouse(out int tx, out int ty))
                {
                    int dx = tx - Controller.Session.TownCenterTx;
                    int dy = ty - Controller.Session.TownCenterTy;

                    if (dx * dx + dy * dy <= TownClickRadiusTiles * TownClickRadiusTiles)
                    {
                        // Do NOT set waypoint when clicking town.
                        FastTravelToTown();
                        return;
                    }
                }
            }

            // --- DEBUG: click artifact marker to teleport ---
            if (DebugShowArtifacts && DebugClickTeleportsToArtifact && UnityEngine.Input.GetMouseButtonDown(0))
            {
                if (Controller != null && Controller.Session != null && TryGetMapTileUnderMouse(out int tx, out int ty))
                {
                    if (TryFindNearestArtifactUnderClick(Controller.Session, tx, ty, out int aTx, out int aTy))
                    {
                        // Teleport player to artifact tile center
                        var s = Controller.Session;
                        s.Player.PositionX = aTx;
                        s.Player.PositionY = aTy;

                        // Stream chunks around destination for immediate visuals
                        s.Chunks.EnsureActiveRadius(s.Player.PositionX, s.Player.PositionY, s.ActiveChunkRadius);

                        s.PostStatus($"DEBUG TELEPORT: artifact ({aTx},{aTy})", 2.0);

                        // Keep map open so you can click multiple quickly (or set to false if you prefer)
                        // SetVisible(false);

                        return; // consume click; do NOT set waypoint this frame
                    }
                }
            }

            // --- Waypoint click handling ---
            if (AllowWaypoint && Waypoints != null)
            {
                // Left click = set waypoint, Right click = clear waypoint
                if (UnityEngine.Input.GetMouseButtonDown(0))
                {
                    if (TryGetMapTileUnderMouse(out int tx, out int ty))
                    {
                        // Prefer deposit click waypoint to deposit center
                        if (DepositClickSetsWaypoint && TryFindNearestDepositUnderClick(Controller.Session, tx, ty, out int dTx, out int dTy))
                        {
                            Waypoints.SetWaypoint(dTx, dTy);
                        }
                        else
                        {
                            Waypoints.SetWaypoint(tx, ty);
                        }
                    }
                }
                else if (UnityEngine.Input.GetMouseButtonDown(1))
                {
                    Waypoints.ClearWaypoint();
                }
            }


            if (Time.unscaledTime < _nextUpdateTime) return;
            _nextUpdateTime = Time.unscaledTime + (1f / UpdatesPerSecond);

            EnsureTexture(Controller.Session);
            RenderMap(Controller.Session);
        }

        public void DebugSetArtifactsOverlay(bool enabled, bool openMap = true)
        {
            DebugShowArtifacts = enabled;

            if (openMap)
                SetVisible(true); // OK because we're inside the same class

            // Force immediate refresh when toggled.
            _nextUpdateTime = 0f;
        }

        private void SetVisible(bool v)
        {
            _visible = v;

            if (Waypoints != null)
                Waypoints.IsMapOpen = v;

            if (MapCanvasGroup != null)
            {
                MapCanvasGroup.alpha = v ? 1f : 0f;
                MapCanvasGroup.interactable = v;
                MapCanvasGroup.blocksRaycasts = v;
            }
            else if (MapRoot != null)
            {
                // Fallback if CanvasGroup not wired
                MapRoot.SetActive(v);
            }

            // When opening, force immediate refresh
            _nextUpdateTime = 0f;

            if (v && LegendText != null)
            {
                LegendText.text = BuildLegendString();
            }
        }

        private void EnsureTexture(GameSession s)
        {
            int w = s.Fog.Width;
            int h = s.Fog.Height;

            if (_tex != null && _tex.width == w && _tex.height == h && _pixels != null && _pixels.Length == w * h)
                return;

            _tex = new Texture2D(w, h, TextureFormat.RGBA32, mipChain: false);
            _tex.wrapMode = TextureWrapMode.Clamp;
            _tex.filterMode = FilterMode.Point;

            _pixels = new Color32[w * h];

            MapImage.texture = _tex;

            // NOTE: RawImage may not support preserveAspect in this Unity/UI version.
            // Use RectTransform + AspectRatioFitter on the MapImage object if you want aspect preservation.
        }

        private void FastTravelToTown()
        {
            if (Controller == null || Controller.Session == null) return;

            var s = Controller.Session;

            if (!AllowFastTravelToTown)
                return;

            int cost = Mathf.Max(0, FastTravelCostCredits);

            if (cost > 0 && !s.TrySpendCredits(cost))
            {
                s.PostStatus($"FAST TRAVEL FAILED: need {cost} cr", 2.0);
                return; // keep map open
            }

            // Teleport player to town center
            s.Player.PositionX = s.TownCenterTx;
            s.Player.PositionY = s.TownCenterTy;

            // Ensure chunks around town are loaded for immediate visuals
            s.Chunks.EnsureActiveRadius(s.Player.PositionX, s.Player.PositionY, s.ActiveChunkRadius);

            s.PostStatus(cost > 0 ? $"FAST TRAVEL: TOWN (-{cost} cr)" : "FAST TRAVEL: TOWN", 1.5);

            // Close map after fast travel success
            SetVisible(false);
        }


        private bool TryGetMapTileUnderMouse(out int tx, out int ty)
        {
            tx = ty = 0;
            if (MapImage == null) return false;

            RectTransform rt = MapImage.rectTransform;

            // Screen-space overlay: camera can be null
            if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rt, UnityEngine.Input.mousePosition, null, out Vector2 local))
                return false;

            Rect r = rt.rect;

            // local is centered at pivot; convert to 0..1 inside rect
            float nx = (local.x - r.xMin) / r.width;
            float ny = (local.y - r.yMin) / r.height;

            // Must be inside the RawImage rect
            if (nx < 0f || nx > 1f || ny < 0f || ny > 1f) return false;

            // Map texture is world-sized (512x512). Convert normalized to tile coords.
            int w = _tex != null ? _tex.width : (Controller != null && Controller.Session != null ? Controller.Session.Fog.Width : 0);
            int h = _tex != null ? _tex.height : (Controller != null && Controller.Session != null ? Controller.Session.Fog.Height : 0);
            if (w <= 0 || h <= 0) return false;

            tx = Mathf.Clamp(Mathf.FloorToInt(nx * w), 0, w - 1);
            ty = Mathf.Clamp(Mathf.FloorToInt(ny * h), 0, h - 1);

            return true;
        }


        private void RenderMap(GameSession s)
        {
            int w = _tex.width;
            int h = _tex.height;

            // 1) Base layer: fog states
            // We render in texture coords where (0,0) is bottom-left.
            // Our fog queries are (tx,ty) with ty increasing downward in your core semantics,
            // but since you’ve already adapted Y semantics for movement/rendering, we’ll keep
            // the mapping direct: (tx,ty) -> pixel (tx,ty). If you want Y flipped visually,
            // we can do it with one line change.
            for (int ty = 0; ty < h; ty++)
            {
                int row = ty * w;
                for (int tx = 0; tx < w; tx++)
                {
                    Color32 c;

                    if (!s.Fog.IsDiscovered(tx, ty))
                        c = Undiscovered;
                    else if (!s.Fog.IsVisibleNow(tx, ty))
                        c = Discovered;
                    else
                        c = VisibleNow;

                    _pixels[row + tx] = c;
                }
            }

            // 2) DEBUG artifact markers (show even if undiscovered)
            if (DebugShowArtifacts && s.Deposits != null)
            {
                int n = s.Deposits.GetArtifactSpawnCount();
                for (int i = 0; i < n; i++)
                {
                    if (!s.Deposits.TryGetArtifactSpawn(i, out _, out int ax, out int ay, out _, out _))
                        continue;

                    DrawDot(w, h, ax, ay, ArtifactDotRadius, ArtifactDebugColor);
                }
            }

            // 3) Deposit markers (discovered only)
            foreach (var d in s.Deposits.GetAllDeposits())
            {
                if (!d.DiscoveredByPlayer) continue;
                if (d.RemainingUnits <= 0) continue;

                Color32 dc;
                if (d.ClaimedByPlayer) dc = DepositPlayer;
                else if (d.ClaimedByNpcId.HasValue) dc = DepositNpc;
                else dc = DepositUnclaimed;

                Color32 finalColor = dc;

                // If NPC-claimed and nearly depleted darken / redden
                if (d.ClaimedByNpcId.HasValue && d.RemainingUnits > 0)
                {
                    NpcMinerManager.NpcMiner npc = null;

                    var npcList = s.Npcs?.Npcs;
                    if (npcList != null)
                    {
                        for (int i = 0; i < npcList.Count; i++)
                        {
                            if (npcList[i].NpcId == d.ClaimedByNpcId.Value)
                            {
                                npc = npcList[i];
                                break;
                            }
                        }
                    }

                    if (npc != null)
                    {
                        double rate = s.Npcs.GetNpcExtractionRateKgPerSec(npc, d.OreTypeId);
                        double eta = d.EstimateSecondsToDeplete(rate);

                        if (eta <= DepletionWarningSeconds)
                        {
                            finalColor = new Color32(200, 40, 40, 255); // urgent red
                        }
                    }
                }

                DrawDot(w, h, d.CenterTx, d.CenterTy, DepositDotRadius, finalColor);
            }

            // 4) Town marker (always visible on map; tweak rule later if desired)
            if (ShowTownMarker)
            {
                int tTx = Mathf.Clamp(s.TownCenterTx, 0, w - 1);
                int tTy = Mathf.Clamp(s.TownCenterTy, 0, h - 1);

                DrawDot(w, h, tTx, tTy, TownDotRadius, TownColor);
            }

            // 5) Player dot (always)
            int pTx = Mathf.Clamp(Mathf.FloorToInt((float)s.Player.PositionX), 0, w - 1);
            int pTy = Mathf.Clamp(Mathf.FloorToInt((float)s.Player.PositionY), 0, h - 1);
            DrawDot(w, h, pTx, pTy, PlayerDotRadius, PlayerColor);

            // 6) Waypoint marker
            if (Waypoints != null && Waypoints.HasWaypoint)
            {
                DrawDot(w, h, Waypoints.WaypointTx, Waypoints.WaypointTy, WaypointDotRadius, WaypointColor);
            }

            // Apply
            _tex.SetPixels32(_pixels);
            _tex.Apply(updateMipmaps: false, makeNoLongerReadable: false);
        }

        private void DrawDot(int w, int h, int cx, int cy, int r, Color32 c)
        {
            int r2 = r * r;

            int minX = Mathf.Max(0, cx - r);
            int maxX = Mathf.Min(w - 1, cx + r);
            int minY = Mathf.Max(0, cy - r);
            int maxY = Mathf.Min(h - 1, cy + r);

            for (int y = minY; y <= maxY; y++)
            {
                int dy = y - cy;
                int row = y * w;
                for (int x = minX; x <= maxX; x++)
                {
                    int dx = x - cx;
                    if (dx * dx + dy * dy > r2) continue;
                    _pixels[row + x] = c;
                }
            }
        }

        private bool TryFindNearestArtifactUnderClick(GameSession s, int clickTx, int clickTy, out int artifactTx, out int artifactTy)
        {
            artifactTx = artifactTy = 0;
            if (s == null || s.Deposits == null) return false;

            int r = Mathf.Max(0, DebugArtifactClickRadiusTiles);
            int r2 = r * r;

            int bestDist2 = int.MaxValue;
            bool found = false;

            int n = s.Deposits.GetArtifactSpawnCount();
            for (int i = 0; i < n; i++)
            {
                if (!s.Deposits.TryGetArtifactSpawn(i, out _, out int ax, out int ay, out _, out _))
                    continue;

                int dx = ax - clickTx;
                int dy = ay - clickTy;
                int dist2 = dx * dx + dy * dy;

                if (dist2 <= r2 && dist2 < bestDist2)
                {
                    bestDist2 = dist2;
                    artifactTx = ax;
                    artifactTy = ay;
                    found = true;
                }
            }

            return found;
        }

        private bool TryFindNearestDepositUnderClick(GameSession s, int clickTx, int clickTy, out int depositTx, out int depositTy)
        {
            depositTx = depositTy = 0;
            if (s == null) return false;

            int r = Mathf.Max(0, DepositClickRadiusTiles);
            int r2 = r * r;

            int bestDist2 = int.MaxValue;
            int bestTx = 0, bestTy = 0;
            bool found = false;

            foreach (var d in s.Deposits.GetAllDeposits())
            {
                if (!d.DiscoveredByPlayer) continue;
                if (d.RemainingUnits <= 0) continue;

                int dx = d.CenterTx - clickTx;
                int dy = d.CenterTy - clickTy;
                int dist2 = dx * dx + dy * dy;

                if (dist2 <= r2 && dist2 < bestDist2)
                {
                    bestDist2 = dist2;
                    bestTx = d.CenterTx;
                    bestTy = d.CenterTy;
                    found = true;
                }
            }

            if (!found) return false;

            depositTx = bestTx;
            depositTy = bestTy;
            return true;
        }

        private string BuildLegendString()
        {
            // Text-only legend. Colors are represented by words; UI colors are already visible on the map.
            // Keep it short so it reads at a glance.
            return
                "MAP LEGEND\n" +
                "• White: You\n" +
                "• Yellow: Town\n" +
                "• Cyan: Unclaimed Deposit\n" +
                "• Green: Your Claim\n" +
                "• Orange: NPC Claim\n" +
                "• Gray: Explored\n" +
                "• Black: Unknown\n" +
                "• Blue: Waypoint\n";
        }

    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\NightLightingController.cs =====
using UnityEngine;
using MineIt.Simulation;

namespace MineItUnity.Game
{
    /// <summary>
    /// Night lighting using SpriteMask:
    /// - A fullscreen black overlay whose alpha follows Clock.Darkness01
    /// - A circular SpriteMask centered on player, so overlay is visible outside the mask
    /// </summary>
    public sealed class NightLightingController : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;

        [Header("Tuning")]
        [Range(0f, 1f)]
        public float MaxDarkness = 0.65f;

        // Light radius in tiles (Unity units), matches your MVP night vision until you add a flashlight system.
        public float NightLightRadiusTiles = 6f;

        // How many screen tiles beyond camera bounds to ensure overlay fully covers
        public float OverlayPaddingTiles = 2f;

        [Header("Sorting")]
        public int OverlaySortingOrder = 100; // above world/fog, below future UI

        private Camera _cam;

        private GameObject _overlayObj;
        private SpriteRenderer _overlaySr;

        private GameObject _maskObj;
        private SpriteMask _mask;

        private Sprite _whiteSprite;       // 1x1 white, for overlay
        private Sprite _circleMaskSprite;  // circle sprite for SpriteMask

        private void Awake()
        {
            _cam = Camera.main;

            _whiteSprite = CreateSolidSprite();
            _circleMaskSprite = CreateCircleMaskSprite(sizePx: 128);

            CreateOverlayObjects();
        }

        private void LateUpdate()
        {
            if (Controller == null || Controller.Session == null) return;
            if (_cam == null) _cam = Camera.main;
            if (_cam == null || !_cam.orthographic) return;

            var clock = Controller.Session.Clock;

            float darkness01 = (float)clock.Darkness01;
            float overlayAlpha = darkness01 * MaxDarkness;

            // If no darkness, hide overlay entirely
            bool active = overlayAlpha > 0.001f;
            if (_overlayObj.activeSelf != active) _overlayObj.SetActive(active);
            if (_maskObj.activeSelf != active) _maskObj.SetActive(active);

            if (!active) return;

            // 1) Position & scale overlay to cover camera view
            FitOverlayToCamera();

            // 2) Set overlay alpha
            var c = _overlaySr.color;
            c.r = 0f; c.g = 0f; c.b = 0f;
            c.a = overlayAlpha;
            _overlaySr.color = c;

            // 3) Move mask to player and scale to radius
            float px = (float)Controller.Session.Player.PositionX;
            float py = (float)Controller.Session.Player.PositionY;

            _maskObj.transform.position = new Vector3(px, py, 0f);

            // SpriteMask scale: our circle sprite is normalized to 1 unit in size
            float radius = NightLightRadiusTiles;
            float diameter = radius * 2f;
            _maskObj.transform.localScale = new Vector3(diameter, diameter, 1f);
        }

        private void CreateOverlayObjects()
        {
            // Parent for cleanliness
            var root = new GameObject("NightLighting");
            root.transform.SetParent(transform, worldPositionStays: false);

            // --- Darkness overlay ---
            _overlayObj = new GameObject("NightOverlay");
            _overlayObj.transform.SetParent(root.transform, worldPositionStays: false);

            _overlaySr = _overlayObj.AddComponent<SpriteRenderer>();
            _overlaySr.sprite = _whiteSprite;
            _overlaySr.sortingOrder = OverlaySortingOrder;

            // Critical: show darkness OUTSIDE the mask (hole in the middle)
            _overlaySr.maskInteraction = SpriteMaskInteraction.VisibleOutsideMask;

            // --- Player light mask ---
            _maskObj = new GameObject("PlayerLightMask");
            _maskObj.transform.SetParent(root.transform, worldPositionStays: false);

            _mask = _maskObj.AddComponent<SpriteMask>();
            _mask.sprite = _circleMaskSprite;

            // Ensure mask affects overlay: default is fine, but keep consistent
            _mask.isCustomRangeActive = true;
            _mask.frontSortingOrder = OverlaySortingOrder + 1;
            _mask.backSortingOrder = OverlaySortingOrder - 1;
        }

        private void FitOverlayToCamera()
        {
            // Overlay should follow camera center
            Vector3 camPos = _cam.transform.position;
            _overlayObj.transform.position = new Vector3(camPos.x, camPos.y, 0f);

            float halfH = _cam.orthographicSize + OverlayPaddingTiles;
            float halfW = halfH * _cam.aspect;

            // Our overlay sprite is 1 unit wide/high; scale it to cover view
            float w = halfW * 2f;
            float h = halfH * 2f;

            _overlayObj.transform.localScale = new Vector3(w, h, 1f);
        }

        private static Sprite CreateSolidSprite()
        {
            var tex = new Texture2D(1, 1, TextureFormat.RGBA32, false);
            tex.SetPixel(0, 0, Color.white);
            tex.Apply();
            return Sprite.Create(tex, new Rect(0, 0, 1, 1), new Vector2(0.5f, 0.5f), 1);
        }

        private static Sprite CreateCircleMaskSprite(int sizePx)
        {
            // White circle on transparent background
            var tex = new Texture2D(sizePx, sizePx, TextureFormat.RGBA32, false);
            tex.wrapMode = TextureWrapMode.Clamp;
            tex.filterMode = FilterMode.Bilinear;

            float cx = (sizePx - 1) * 0.5f;
            float cy = (sizePx - 1) * 0.5f;
            float r = (sizePx * 0.5f) - 1f;
            float r2 = r * r;

            for (int y = 0; y < sizePx; y++)
                for (int x = 0; x < sizePx; x++)
                {
                    float dx = x - cx;
                    float dy = y - cy;
                    float d2 = dx * dx + dy * dy;

                    // Inside circle: alpha 1, outside: alpha 0
                    float a = d2 <= r2 ? 1f : 0f;
                    tex.SetPixel(x, y, new Color(1f, 1f, 1f, a));
                }

            tex.Apply();

            return Sprite.Create(tex, new Rect(0, 0, sizePx, sizePx), new Vector2(0.5f, 0.5f), 1);
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\ScanRingRenderer.cs =====
using UnityEngine;
using MineItUnity.Game;

namespace MineItUnity.Game
{
    /// <summary>
    /// Renders a temporary scan ring when a scan executes.
    /// Pure presentation: reads GameSession state only.
    /// </summary>
    public sealed class ScanRingRenderer : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;

        [Header("Visuals")]
        [Tooltip("Ring color at full intensity")]
        public Color RingColor = new Color(0.2f, 1.0f, 1.0f, 1.0f); // cyan
        public float RingThickness = 0.06f;
        public int SortingOrder = 25;

        private SpriteRenderer _sr;
        private Sprite _ringSprite;

        private void Awake()
        {
            _ringSprite = CreateRingSprite(sizePx: 256, thicknessPx: 6);

            var go = new GameObject("ScanRing");
            go.transform.SetParent(transform, worldPositionStays: false);

            _sr = go.AddComponent<SpriteRenderer>();
            _sr.sprite = _ringSprite;
            _sr.sortingOrder = SortingOrder;
            _sr.enabled = false;
        }

        private void LateUpdate()
        {
            if (Controller == null || Controller.Session == null)
                return;

            var s = Controller.Session;

            if (s.LastScanFlashSeconds <= 0)
            {
                _sr.enabled = false;
                return;
            }

            _sr.enabled = true;

            // Center on scan origin (tile center)
            float cx = s.LastScanCenterTx + 0.5f;
            float cy = s.LastScanCenterTy + 0.5f;
            _sr.transform.position = new Vector3(cx, cy, 0f);

            // Scale ring: diameter = radius * 2
            float radius = s.LastScanRadiusTiles;
            float diameter = radius * 2f;
            _sr.transform.localScale = new Vector3(diameter, diameter, 1f);

            // Fade based on remaining flash time
            float alpha = Mathf.Clamp01((float)(s.LastScanFlashSeconds / 0.35));
            var c = RingColor;
            c.a *= alpha;
            _sr.color = c;
        }

        private static Sprite CreateRingSprite(int sizePx, int thicknessPx)
        {
            var tex = new Texture2D(sizePx, sizePx, TextureFormat.RGBA32, false);
            tex.wrapMode = TextureWrapMode.Clamp;
            tex.filterMode = FilterMode.Bilinear;

            float cx = (sizePx - 1) * 0.5f;
            float cy = (sizePx - 1) * 0.5f;
            float rOuter = (sizePx * 0.5f) - 1f;
            float rInner = rOuter - thicknessPx;

            float rOuter2 = rOuter * rOuter;
            float rInner2 = rInner * rInner;

            for (int y = 0; y < sizePx; y++)
                for (int x = 0; x < sizePx; x++)
                {
                    float dx = x - cx;
                    float dy = y - cy;
                    float d2 = dx * dx + dy * dy;

                    bool insideRing = (d2 <= rOuter2) && (d2 >= rInner2);
                    tex.SetPixel(x, y, new Color(1f, 1f, 1f, insideRing ? 1f : 0f));
                }

            tex.Apply();
            return Sprite.Create(tex, new Rect(0, 0, sizePx, sizePx), new Vector2(0.5f, 0.5f), 1);
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\Town\TownPanelController.cs =====
using System.Text;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace MineItUnity.Game.Town
{
    /// <summary>
    /// Minimal town panel: Deposit, Sell, Buy next tiers.
    /// Opens only while in town zone.
    /// Can auto-build its UI at runtime if references aren't wired.
    /// </summary>
    public sealed class TownPanelController : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;

        [Header("UI (optional - auto-built if null)")]
        public CanvasGroup RootGroup;
        public TextMeshProUGUI BodyText;

        public Button DepositButton;
        public Button SellButton;

        public Button BuyDetectorButton;
        public Button BuyExtractorButton;
        public Button BuyBackpackButton;

        public Button CloseButton;

        [Header("Input")]
        public KeyCode ToggleKey = KeyCode.B;

        [Header("Update Rate")]
        public float UpdatesPerSecond = 6f;

        private bool _visible;
        private float _nextUpdateTime;
        private readonly StringBuilder _sb = new StringBuilder(1024);

        private void Awake()
        {
            if (Controller == null)
                Controller = FindObjectOfType<GameController>();

            EnsureUi();
            WireButtons();

            SetVisible(false);
        }

        private void Update()
        {
            if (Controller == null || Controller.Session == null)
                return;

            // Force closed outside town
            if (!Controller.Session.IsInTownZone && _visible)
                SetVisible(false);

            // Toggle only in town
            if (Input.GetKeyDown(ToggleKey) && Controller.Session.IsInTownZone)
                SetVisible(!_visible);

            if (!_visible) return;

            if (Time.unscaledTime < _nextUpdateTime) return;
            _nextUpdateTime = Time.unscaledTime + (1f / Mathf.Max(1f, UpdatesPerSecond));

            RefreshTextAndButtons();
        }

        private void RefreshTextAndButtons()
        {
            var s = Controller.Session;

            _sb.Clear();
            _sb.Append("TOWN\n");
            _sb.Append("Credits: ").Append(s.Credits).AppendLine();

            // Backpack summary
            _sb.Append("Backpack: ")
               .Append(s.Backpack.CurrentKg.ToString("0.0"))
               .Append("/")
               .Append(s.Backpack.CapacityKg.ToString("0.0"))
               .Append(" kg")
               .AppendLine();

            // Town storage summary (top few stacks)
            _sb.Append("Storage:\n");
            int shown = 0;
            foreach (var kv in s.TownStorage.OreUnits)
            {
                if (kv.Value <= 0) continue;
                _sb.Append("  ").Append(kv.Key).Append(": ").Append(kv.Value).AppendLine();
                shown++;
                if (shown >= 6) { _sb.Append("  ...\n"); break; }
            }
            if (shown == 0) _sb.Append("  (empty)\n");

            // Artifacts in Vault (fixed order + completion counter)
            string[] ordered = {"stellar_shard", "ancient_lattice", "void_compass", "quantum_fossil", "machine_relic", "echo_prism"};

            int have = 0;
            for (int i = 0; i < ordered.Length; i++)
            {
                if (s.TownStorage.HasArtifact(ordered[i])) have++;
            }

            _sb.Append("Artifacts (Vault): ")
               .Append(have).Append('/').Append(ordered.Length)
               .AppendLine();

            for (int i = 0; i < ordered.Length; i++)
            {
                string id = ordered[i];
                bool ok = s.TownStorage.HasArtifact(id);

                _sb.Append("  ")
                   .Append(ok ? "[X] " : "[ ] ")
                   .Append(PrettyArtifactName(id))
                   .AppendLine();
            }

            if (s.HasWon)
            {
                _sb.AppendLine();
                _sb.AppendLine("Directive: COMPLETE");
            }
            else if (s.VaultAuthInProgress)
            {
                _sb.AppendLine();
                _sb.Append("Vault Authentication: ")
                   .Append(Mathf.CeilToInt((float)s.VaultAuthRemainingSeconds))
                   .AppendLine("s");
            }


            // Upgrades (next tier)
            int detNext = Mathf.Clamp(s.Player.DetectorTier + 1, 1, 5);
            int extNext = Mathf.Clamp(s.Player.ExtractorTier + 1, 1, 5);
            int bagNext = Mathf.Clamp(s.BackpackTier + 1, 1, 5);

            int detCost = MineIt.Inventory.UpgradeCatalog.DetectorPriceForTier(detNext);
            int extCost = MineIt.Inventory.UpgradeCatalog.ExtractorPriceForTier(extNext);
            int bagCost = MineIt.Inventory.UpgradeCatalog.BackpackPriceForTier(bagNext);

            _sb.AppendLine();
            _sb.Append("Upgrades (next tier):\n");
            _sb.Append("  Detector T").Append(s.Player.DetectorTier).Append(" → T").Append(detNext)
               .Append("  (").Append(detCost).Append(" cr)\n");
            _sb.Append("  Extractor T").Append(s.Player.ExtractorTier).Append(" → T").Append(extNext)
               .Append("  (").Append(extCost).Append(" cr)\n");
            _sb.Append("  Backpack T").Append(s.BackpackTier).Append(" → T").Append(bagNext)
               .Append("  (").Append(bagCost).Append(" cr)\n");

            if (BodyText != null)
                BodyText.text = _sb.ToString();

            // Buttons enable/labels
            if (DepositButton != null) DepositButton.interactable = true;
            if (SellButton != null) SellButton.interactable = true;

            if (BuyDetectorButton != null) BuyDetectorButton.interactable = (s.Player.DetectorTier < 5 && s.Credits >= detCost);
            if (BuyExtractorButton != null) BuyExtractorButton.interactable = (s.Player.ExtractorTier < 5 && s.Credits >= extCost);
            if (BuyBackpackButton != null) BuyBackpackButton.interactable = (s.BackpackTier < 5 && s.Credits >= bagCost);
        }

        private static string PrettyArtifactName(string id)
        {
            if (string.IsNullOrWhiteSpace(id)) return "(unknown)";
            // "stellar_shard" -> "Stellar Shard"
            string s = id.Replace('_', ' ').Trim();
            if (s.Length == 0) return "(unknown)";

            var parts = s.Split(' ');
            for (int i = 0; i < parts.Length; i++)
            {
                var p = parts[i];
                if (p.Length == 0) continue;
                parts[i] = char.ToUpperInvariant(p[0]) + (p.Length > 1 ? p.Substring(1) : "");
            }

            return string.Join(" ", parts);
        }

        private void WireButtons()
        {
            if (DepositButton != null)
                DepositButton.onClick.AddListener(() =>
                {
                    if (Controller?.Session == null) return;
                    Controller.Session.TryDepositBackpackToTown(out _);
                    RefreshTextAndButtons();
                });

            if (SellButton != null)
                SellButton.onClick.AddListener(() =>
                {
                    if (Controller?.Session == null) return;
                    Controller.Session.TrySellTownOre(out _, out _);
                    RefreshTextAndButtons();
                });

            if (BuyDetectorButton != null)
                BuyDetectorButton.onClick.AddListener(() =>
                {
                    if (Controller?.Session == null) return;
                    int next = Mathf.Clamp(Controller.Session.Player.DetectorTier + 1, 1, 5);
                    Controller.Session.TryBuyDetectorTier(next);
                    RefreshTextAndButtons();
                });

            if (BuyExtractorButton != null)
                BuyExtractorButton.onClick.AddListener(() =>
                {
                    if (Controller?.Session == null) return;
                    int next = Mathf.Clamp(Controller.Session.Player.ExtractorTier + 1, 1, 5);
                    Controller.Session.TryBuyExtractorTier(next);
                    RefreshTextAndButtons();
                });

            if (BuyBackpackButton != null)
                BuyBackpackButton.onClick.AddListener(() =>
                {
                    if (Controller?.Session == null) return;
                    int next = Mathf.Clamp(Controller.Session.BackpackTier + 1, 1, 5);
                    Controller.Session.TryBuyBackpackTier(next);
                    RefreshTextAndButtons();
                });

            if (CloseButton != null)
                CloseButton.onClick.AddListener(() => SetVisible(false));
        }

        private void SetVisible(bool v)
        {
            _visible = v;

            if (RootGroup != null)
            {
                RootGroup.alpha = v ? 1f : 0f;
                RootGroup.interactable = v;
                RootGroup.blocksRaycasts = v;
            }

            _nextUpdateTime = 0f;
        }

        private void EnsureUi()
        {
            // If everything is wired, do nothing.
            if (RootGroup != null && BodyText != null &&
                DepositButton != null && SellButton != null &&
                BuyDetectorButton != null && BuyExtractorButton != null && BuyBackpackButton != null &&
                CloseButton != null)
                return;

            // Find a canvas to parent under (your scene has HUDCanvas)
            var canvas = FindObjectOfType<Canvas>();
            if (canvas == null)
            {
                Debug.LogWarning("TownPanelController: No Canvas found. Create a Canvas in the scene.");
                return;
            }

            // Root panel
            var rootGO = new GameObject("TownPanel");
            rootGO.transform.SetParent(canvas.transform, worldPositionStays: false);

            var bg = rootGO.AddComponent<Image>();

            // Solid dark background for clarity
            bg.color = new Color(0.08f, 0.10f, 0.08f, 1.0f);

            // Subtle border to separate panel from world
            var outline = rootGO.AddComponent<Outline>();
            outline.effectColor = new Color(5f, 5f, 5f, 0.8f);
            outline.effectDistance = new Vector2(2f, -2f);

            RootGroup = rootGO.AddComponent<CanvasGroup>();

            var rt = rootGO.GetComponent<RectTransform>();
            rt.anchorMin = new Vector2(0.15f, 0.15f);
            rt.anchorMax = new Vector2(0.85f, 0.85f);
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;

            // Body text
            var textGO = new GameObject("TownBodyText");
            textGO.transform.SetParent(rootGO.transform, worldPositionStays: false);

            BodyText = textGO.AddComponent<TextMeshProUGUI>();
            BodyText.fontSize = 24;
            BodyText.alignment = TextAlignmentOptions.TopLeft;
            BodyText.enableWordWrapping = false;

            var trt = textGO.GetComponent<RectTransform>();
            trt.anchorMin = new Vector2(0.05f, 0.20f);
            trt.anchorMax = new Vector2(0.95f, 0.95f);
            trt.offsetMin = Vector2.zero;
            trt.offsetMax = Vector2.zero;

            // Buttons row
            var buttonsGO = new GameObject("TownButtons");
            buttonsGO.transform.SetParent(rootGO.transform, worldPositionStays: false);

            var brt = buttonsGO.AddComponent<RectTransform>();
            brt.anchorMin = new Vector2(0.05f, 0.05f);
            brt.anchorMax = new Vector2(0.95f, 0.16f);
            brt.offsetMin = Vector2.zero;
            brt.offsetMax = Vector2.zero;

            var h = buttonsGO.AddComponent<HorizontalLayoutGroup>();
            h.childForceExpandHeight = true;
            h.childForceExpandWidth = true;
            h.spacing = 10;

            DepositButton = CreateButton(buttonsGO.transform, "Deposit");
            SellButton = CreateButton(buttonsGO.transform, "Sell");

            BuyDetectorButton = CreateButton(buttonsGO.transform, "Buy Detector");
            BuyExtractorButton = CreateButton(buttonsGO.transform, "Buy Extractor");
            BuyBackpackButton = CreateButton(buttonsGO.transform, "Buy Backpack");

            CloseButton = CreateButton(buttonsGO.transform, "Close");
        }

        private static Button CreateButton(Transform parent, string label)
        {
            var go = new GameObject(label.Replace(" ", "") + "Button");
            go.transform.SetParent(parent, worldPositionStays: false);

            var img = go.AddComponent<Image>();
            img.color = new Color(1f, 1f, 1f, 0.15f);

            var btn = go.AddComponent<Button>();

            var rt = go.GetComponent<RectTransform>();
            rt.sizeDelta = new Vector2(0, 0);

            var textGO = new GameObject("Text");
            textGO.transform.SetParent(go.transform, worldPositionStays: false);

            var tmp = textGO.AddComponent<TextMeshProUGUI>();
            tmp.text = label;
            tmp.alignment = TextAlignmentOptions.Center;
            tmp.fontSize = 22;

            var trt = textGO.GetComponent<RectTransform>();
            trt.anchorMin = Vector2.zero;
            trt.anchorMax = Vector2.one;
            trt.offsetMin = Vector2.zero;
            trt.offsetMax = Vector2.zero;

            return btn;
        }
    }
}

===== FILE: I:\SynologyDrive\Source\Repos\Unity\MineItUnity\MineItUnity\Assets\Scripts\Game\WorldTilemapRenderer.cs =====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;
using MineIt.World;

namespace MineItUnity.Game
{
    /// <summary>
    /// Renders MineIt world chunks into a Unity Tilemap.
    /// One Unity unit == one MineIt tile.
    /// </summary>
    [RequireComponent(typeof(Tilemap))]
    public sealed class WorldTilemapRenderer : MonoBehaviour
    {
        [Header("References")]
        public GameController Controller;

        [Header("Tiles")]
        public TileBase GrassTile;
        public TileBase RockTile;

        // Track which chunks have already been painted
        private readonly HashSet<ChunkCoord> _paintedChunks = new HashSet<ChunkCoord>();

        private Tilemap _tilemap;

        private void Awake()
        {
            _tilemap = GetComponent<Tilemap>();
        }

        private void LateUpdate()
        {
            if (Controller == null || Controller.Session == null)
                return;

            PaintVisibleChunks();
        }

        private void PaintVisibleChunks()
        {
            var session = Controller.Session;
            var chunks = session.Chunks;

            Camera cam = Camera.main;
            if (cam == null || !cam.orthographic)
                return;

            Vector3 camPos = cam.transform.position;
            float halfHeight = cam.orthographicSize;
            float halfWidth = halfHeight * cam.aspect;

            // Determine visible tile bounds
            int minTx = Mathf.FloorToInt(camPos.x - halfWidth) - 2;
            int maxTx = Mathf.CeilToInt(camPos.x + halfWidth) + 2;
            int minTy = Mathf.FloorToInt(camPos.y - halfHeight) - 2;
            int maxTy = Mathf.CeilToInt(camPos.y + halfHeight) + 2;

            minTx = Mathf.Clamp(minTx, 0, chunks.WorldWidthTiles - 1);
            maxTx = Mathf.Clamp(maxTx, 0, chunks.WorldWidthTiles - 1);
            minTy = Mathf.Clamp(minTy, 0, chunks.WorldHeightTiles - 1);
            maxTy = Mathf.Clamp(maxTy, 0, chunks.WorldHeightTiles - 1);

            int chunkSize = Chunk.CHUNK_SIZE_TILES;

            int minCx = minTx / chunkSize;
            int maxCx = maxTx / chunkSize;
            int minCy = minTy / chunkSize;
            int maxCy = maxTy / chunkSize;

            for (int cy = minCy; cy <= maxCy; cy++)
                for (int cx = minCx; cx <= maxCx; cx++)
                {
                    var coord = new ChunkCoord(cx, cy);
                    if (_paintedChunks.Contains(coord))
                        continue;

                    Chunk chunk;
                    try
                    {
                        chunk = chunks.GetOrLoadChunk(cx, cy);
                    }
                    catch
                    {
                        continue;
                    }

                    PaintChunk(chunk);
                    _paintedChunks.Add(coord);
                }
        }

        private void PaintChunk(Chunk chunk)
        {
            int chunkSize = Chunk.CHUNK_SIZE_TILES;
            int baseTx = chunk.Coord.Cx * chunkSize;
            int baseTy = chunk.Coord.Cy * chunkSize;

            for (int ly = 0; ly < chunkSize; ly++)
                for (int lx = 0; lx < chunkSize; lx++)
                {
                    byte t = chunk.GetLocalTile(lx, ly);
                    TileBase tile = (t == 0) ? GrassTile : RockTile;

                    Vector3Int cell = new Vector3Int(
                        baseTx + lx,
                        baseTy + ly,
                        0);

                    _tilemap.SetTile(cell, tile);
                }
        }
    }
}

